/* Generated by: JavaCC 21 Parser Generator. Token.java */
package de.compilerbau.NewAwkCompiler.javacc21;

import java.util.*;
public class Token implements NewAwkConstants, Node {
    private FileLineMap fileLineMap;
    public FileLineMap getFileLineMap() {
        if (fileLineMap== null) {
            Node n= getParent();
            while (n!=null) {
                fileLineMap= n.getFileLineMap();
                if (fileLineMap!=null) break;
                n= n.getParent();
            }
        }
        return fileLineMap;
    }

    public Token(TokenType type, String image, FileLineMap fileLineMap) {
        this.type= type;
        this.image= image;
        this.fileLineMap= fileLineMap;
    }

    public void setInputSource(FileLineMap fileLineMap) {
        this.fileLineMap= fileLineMap;
    }

    private String inputSource= "";
    private TokenType type;
    public TokenType getType() {
        return type;
    }

    void setType(TokenType type) {
        this.type= type;
    }

    /**
     * beginLine and beginColumn describe the position of the first character
     * of this token; endLine and endColumn describe the position of the
     * last character of this token.
     */
    private int beginLine, beginColumn, endLine, endColumn;
    /**
     * The string image of the token.
     */
    private String image;
    public String getImage() {
        if (image== null) {
            return getSource();
        }
        return image;
    }

    public void setImage(String image) {
        this.image= image;
    }

    private LexicalState lexicalState;
    void setLexicalState(LexicalState state) {
        this.lexicalState= state;
    }

    LexicalState getLexicalState() {
        return lexicalState;
    }

    private Token next;
    Token getNext() {
        return next;
    }

    void setNext(Token next) {
        this.next= next;
    }

    /**
     * This field is used to access special tokens that occur prior to this
     * token, but after the immediately preceding regular (non-special) token.
     * If there are no such special tokens, this field is set to null.
     * When there are more than one such special token, this field refers
     * to the last of these special tokens, which in turn refers to the next
     * previous special token through its specialToken field, and so on
     * until the first special token (whose specialToken field is null).
     * The next fields of special tokens refer to other special tokens that
     * immediately follow it (without an intervening regular token).  If there
     * is no such token, this field is null.
     */
    private Token specialToken;
    public Token getSpecialToken() {
        return specialToken;
    }

    public void setSpecialToken(Token specialToken) {
        this.specialToken= specialToken;
    }

    private boolean unparsed;
    //Should find a way to get rid of this.
    Token() {
    }

    public Token(int kind) {
        this(kind, null);
        this.type= TokenType.values()[kind];
    }

    /**
     * Constructs a new token for the specified Image and Kind.
     */
    public Token(int kind, String image) {
        this.type= TokenType.values()[kind];
        this.image= image;
        ;
    }

    public Token(TokenType type, String image, String inputSource) {
        this.type= type;
        this.image= image;
        this.inputSource= inputSource;
    }

    public boolean isUnparsed() {
        return unparsed;
    }

    public void setUnparsed(boolean unparsed) {
        this.unparsed= unparsed;
    }

    public void clearChildren() {
    }

    public String getNormalizedText() {
        if (getType()== TokenType.EOF) {
            return"EOF";
        }
        return getImage();
    }

    public String toString() {
        return getNormalizedText();
    }

    public static Token newToken(TokenType type, String image, FileLineMap fileLineMap) {
        switch(type) {
            case WHITESPACE:
            return new WHITESPACE(TokenType.WHITESPACE, image, fileLineMap);
            case TAB:
            return new TAB(TokenType.TAB, image, fileLineMap);
            case NEW_LINE:
            return new NEW_LINE(TokenType.NEW_LINE, image, fileLineMap);
            case CARRIAGE_RETURN:
            return new CARRIAGE_RETURN(TokenType.CARRIAGE_RETURN, image, fileLineMap);
            case PLUS:
            return new PLUS(TokenType.PLUS, image, fileLineMap);
            case MINUS:
            return new MINUS(TokenType.MINUS, image, fileLineMap);
            case MULTIPLICATION:
            return new MULTIPLICATION(TokenType.MULTIPLICATION, image, fileLineMap);
            case DIVISION:
            return new DIVISION(TokenType.DIVISION, image, fileLineMap);
            case MODULO:
            return new MODULO(TokenType.MODULO, image, fileLineMap);
            case Zuweisung:
            return new Zuweisung(TokenType.Zuweisung, image, fileLineMap);
            case EQUAL:
            return new EQUAL(TokenType.EQUAL, image, fileLineMap);
            case NOT_EQUAL:
            return new NOT_EQUAL(TokenType.NOT_EQUAL, image, fileLineMap);
            case G_OR_EQUAL:
            return new G_OR_EQUAL(TokenType.G_OR_EQUAL, image, fileLineMap);
            case S_OR_EQUAL:
            return new S_OR_EQUAL(TokenType.S_OR_EQUAL, image, fileLineMap);
            case GREATER:
            return new GREATER(TokenType.GREATER, image, fileLineMap);
            case SMALLER:
            return new SMALLER(TokenType.SMALLER, image, fileLineMap);
            case Colon:
            return new Colon(TokenType.Colon, image, fileLineMap);
            case ConditionalAnd:
            return new ConditionalAnd(TokenType.ConditionalAnd, image, fileLineMap);
            case ConditionalOr:
            return new ConditionalOr(TokenType.ConditionalOr, image, fileLineMap);
            case ConditionalNot:
            return new ConditionalNot(TokenType.ConditionalNot, image, fileLineMap);
            case Exponentiation:
            return new Exponentiation(TokenType.Exponentiation, image, fileLineMap);
            case RETURN:
            return new RETURN(TokenType.RETURN, image, fileLineMap);
            case VOID:
            return new VOID(TokenType.VOID, image, fileLineMap);
            case NullLiteral:
            return new NullLiteral(TokenType.NullLiteral, image, fileLineMap);
            case IF:
            return new IF(TokenType.IF, image, fileLineMap);
            case ELSE:
            return new ELSE(TokenType.ELSE, image, fileLineMap);
            case KlammerAuf:
            return new KlammerAuf(TokenType.KlammerAuf, image, fileLineMap);
            case KlammerZu:
            return new KlammerZu(TokenType.KlammerZu, image, fileLineMap);
            case BlockAuf:
            return new BlockAuf(TokenType.BlockAuf, image, fileLineMap);
            case BlockZu:
            return new BlockZu(TokenType.BlockZu, image, fileLineMap);
            case ArrayAuf:
            return new ArrayAuf(TokenType.ArrayAuf, image, fileLineMap);
            case ArrayZu:
            return new ArrayZu(TokenType.ArrayZu, image, fileLineMap);
            case SEMICOLON:
            return new SEMICOLON(TokenType.SEMICOLON, image, fileLineMap);
            case COMMA:
            return new COMMA(TokenType.COMMA, image, fileLineMap);
            case DOT:
            return new DOT(TokenType.DOT, image, fileLineMap);
            case DataType:
            return new DataType(TokenType.DataType, image, fileLineMap);
            case Apostrophe:
            return new Apostrophe(TokenType.Apostrophe, image, fileLineMap);
            case CharLiteral:
            return new CharLiteral(TokenType.CharLiteral, image, fileLineMap);
            case BooleanValue:
            return new BooleanValue(TokenType.BooleanValue, image, fileLineMap);
            case IntegerLiteral:
            return new IntegerLiteral(TokenType.IntegerLiteral, image, fileLineMap);
            case DoubleLiteral:
            return new DoubleLiteral(TokenType.DoubleLiteral, image, fileLineMap);
            case Bezeichner:
            return new Bezeichner(TokenType.Bezeichner, image, fileLineMap);
            case StringLiteral:
            return new StringLiteral(TokenType.StringLiteral, image, fileLineMap);
            default:
            return new Token(type, image, fileLineMap);
        }
    }

    public static Token newToken(TokenType type, String image, NewAwkParser parser) {
        return newToken(type, image, parser.token_source);
    }

    public static Token newToken(TokenType type, String image, NewAwkLexer lexer) {
        return newToken(type, image, lexer.input_stream);
    }

    public static Token newToken(TokenType type, String image, Node node) {
        return newToken(type, image, node.getFileLineMap());
    }

    public void setBeginColumn(int beginColumn) {
        this.beginColumn= beginColumn;
    }

    public void setEndColumn(int endColumn) {
        this.endColumn= endColumn;
    }

    public void setBeginLine(int beginLine) {
        this.beginLine= beginLine;
    }

    public void setEndLine(int endLine) {
        this.endLine= endLine;
    }

    public int getBeginLine() {
        return beginLine;
    }

    public int getBeginColumn() {
        return beginColumn;
    }

    public int getEndLine() {
        return endLine;
    }

    public int getEndColumn() {
        return endColumn;
    }

    private Node parent;
    private Map<String, Object> attributes;
    public void setChild(int i, Node n) {
        throw new UnsupportedOperationException();
    }

    public void addChild(Node n) {
        throw new UnsupportedOperationException();
    }

    public void addChild(int i, Node n) {
        throw new UnsupportedOperationException();
    }

    public Node removeChild(int i) {
        throw new UnsupportedOperationException();
    }

    public boolean removeChild(Node n) {
        return false;
    }

    public int indexOf(Node n) {
        return-1;
    }

    public Node getParent() {
        return parent;
    }

    public void setParent(Node parent) {
        this.parent= parent;
    }

    public int getChildCount() {
        return 0;
    }

    public Node getChild(int i) {
        return null;
    }

    public List<Node> children() {
        return Collections.emptyList();
    }

    public void open() {
    }

    public void close() {
    }

    public Object getAttribute(String name) {
        return attributes== null?null:
        attributes.get(name);
    }

    public void setAttribute(String name, Object value) {
        if (attributes== null) {
            attributes= new HashMap<String, Object> ();
        }
        attributes.put(name, value);
    }

    public boolean hasAttribute(String name) {
        return attributes== null?false:
        attributes.containsKey(name);
    }

    public Set<String> getAttributeNames() {
        if (attributes== null) return Collections.emptySet();
        return attributes.keySet();
    }

    /** Accept the visitor. **/
    public Object jjtAccept(NewAwkParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    /** Accept the visitor. **/
    public Object childrenAccept(NewAwkParserVisitor visitor, Object data) {
        return data;
    }

}
