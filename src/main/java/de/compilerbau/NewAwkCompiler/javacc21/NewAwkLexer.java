/* Generated by: JavaCC 21 Parser Generator. NewAwkLexer.java */
package de.compilerbau.NewAwkCompiler.javacc21;

import static de.compilerbau.NewAwkCompiler.javacc21.NewAwkConstants.TokenType.*;
import de.compilerbau.NewAwkCompiler.Visitors.*;
import de.compilerbau.NewAwkCompiler.javacc21.*;
import java.io.*;
import java.util.*;
import java.io.Reader;
import java.io.IOException;
import java.util.logging.Logger;
import java.util.*;
@SuppressWarnings("unused")
public class NewAwkLexer implements NewAwkConstants {
    private static final Logger LOGGER= Logger.getLogger("NewAwkParser");
    private boolean trace_enabled= false;
    private void setTracingEnabled(boolean trace_enabled) {
        this.trace_enabled= trace_enabled;
    }

    public String getInputSource() {
        return inputSource;
    }

    public void setInputSource(String inputSource) {
        this.inputSource= inputSource;
        input_stream.setInputSource(inputSource);
    }

    public NewAwkLexer(String inputSource, CharSequence chars) {
        this(inputSource, chars, LexicalState.DEFAULT, 1, 1);
    }

    public NewAwkLexer(String inputSource, CharSequence chars, LexicalState lexState, int line, int column) {
        input_stream= new FileLineMap(inputSource, chars, line, column);
        switchTo(lexState);
    }

    public NewAwkLexer(String inputSource, Reader reader) {
        this(inputSource, reader, LexicalState.DEFAULT, 1, 1);
    }

    /**
     * @deprecated Use the constructor where you specify an inputSource string so that you can have error messages that make sense!
     */
    @Deprecated public NewAwkLexer(Reader reader) {
        this("input", reader);
    }

    public NewAwkLexer(String inputSource, Reader reader, LexicalState lexState, int line, int column) {
        input_stream= new FileLineMap(inputSource, reader, line, column);
        switchTo(lexState);
    }

    FileLineMap input_stream;
    public final void backup(int amount) {
        input_stream.backup(amount);
    }

    LexicalState lexicalState= LexicalState.DEFAULT;
    void addToken(Token token) {
        input_stream.addToken(token);
    }

    int tabSize= 8;
    /** Switch to specified lexical state. */
    public boolean switchTo(LexicalState lexState) {
        if (this.lexicalState!=lexState) {
            if (trace_enabled) LOGGER.info("Switching from lexical state "+this.lexicalState+" to "+lexState);
            this.lexicalState= lexState;
            return true;
        }
        return false;
    }

    private InvalidToken invalidToken;
    private Token pendingToken;
    public Token getNextToken() {
        if (pendingToken!=null) {
            Token result= pendingToken;
            pendingToken= null;
            return result;
        }
        Token tok= null;
        do {
            tok= nextToken();
        }
        while (tok instanceof InvalidToken);
        if (invalidToken!=null) {
            addToken(invalidToken);
            invalidToken.setNext(tok);
            Token it= invalidToken;
            pendingToken= tok;
            this.invalidToken= null;
            return it;
        }
        addToken(tok);
        return tok;
    }

    static public String addEscapes(String s) {
        return ParseException.addEscapes(s);
    }

    // Reset the token source input
    // to just after the Token passed in.
    void reset(Token t) {
        input_stream.goTo(t.getEndLine(), t.getEndColumn());
        input_stream.forward(1);
    }

    FileLineMap getFileLineMap() {
        return input_stream;
    }

    private int jjnewStateCnt;
    private int jjround;
    private int jjmatchedPos;
    //FIXME,should be an enum.
    private int jjmatchedKind;
    private String inputSource= "input";
    // BitSet for TOKEN
    static private BitSet tokenSet= BitSet.valueOf(new long[]{-2340745906325815327L, 4095L, });
    private final int[] jjrounds= new int[46];
    private final int[] jjstateSet= new int[92];
    private final StringBuilder image= new StringBuilder();
    private int matchedCharsLength;
    char curChar;
    // Method to reinitialize the jjrounds array.
    private void ReInitRounds() {
        int i;
        jjround= 0x80000001;
        for (i= 46; i--> 0; ) jjrounds[i]= 0x80000000;
    }

    private Token nextToken() {
        Token specialToken= null;
        Token matchedToken;
        int curPos= 0;
        EOFLoop:
        while (true) {
            int retval1= input_stream.beginToken();
            curChar= (char)(retval1);
            if (retval1== -1) {
                // Handle end of file
                if (trace_enabled) LOGGER.info("Returning the <EOF> token.");
                jjmatchedKind= 0;
                Token eof= jjFillToken();
                tokenLexicalActions();
                eof.setSpecialToken(specialToken);
                addToken(eof);
                return eof;
            }
            image.setLength(0);
            matchedCharsLength= 0;
            while (curChar<=32&&(0x100002600L&(1L<<curChar))!=0L) {
                if (trace_enabled) LOGGER.info("Skipping character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+")");
                curChar= (char) input_stream.beginToken();
                if (curChar== (char)-1) {
                    continue EOFLoop;
                }
            }
            jjmatchedKind= 0x7FFFFFFF;
            jjmatchedPos= 0;
            if (trace_enabled) LOGGER.info("Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") "+"at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
            curPos= jjMoveStringLiteralDfa0();
            if (jjmatchedKind!=0x7FFFFFFF) {
                if (jjmatchedPos+1<curPos) {
                    if (trace_enabled) LOGGER.info("   Putting back "+(curPos-jjmatchedPos-1)+" characters into the input stream.");
                    input_stream.backup(curPos-jjmatchedPos-1);
                }
                if (trace_enabled) LOGGER.info("****** FOUND A "+tokenImage[jjmatchedKind]+" MATCH ("+addEscapes(input_stream.getSuffix(jjmatchedPos+2))+") ******\n");
                if (tokenSet.get(jjmatchedKind)) {
                    matchedToken= jjFillToken();
                    tokenLexicalActions();
                    jjmatchedKind= matchedToken.getType().ordinal();
                    addToken(matchedToken);
                    return matchedToken;
                }
                else {
                    continue EOFLoop;
                }
            }
            int error_line= input_stream.getEndLine();
            int error_column= input_stream.getEndColumn();
            String error_after= null;
            error_after= curPos<=1?"":
            input_stream.getImage();
            if (invalidToken== null) {
                invalidToken= new InvalidToken(""+curChar, input_stream);
                invalidToken.setBeginLine(error_line);
                invalidToken.setBeginColumn(error_column);
            }
            else {
                invalidToken.setImage(invalidToken.getImage()+curChar);
            }
            invalidToken.setEndLine(error_line);
            invalidToken.setEndColumn(error_column);
            return invalidToken;
        }
    }

    private void tokenLexicalActions() {
        switch(jjmatchedKind) {
            default:
            break;
        }
    }

    private Token jjFillToken() {
        final Token t;
        final String curTokenImage;
        final int beginLine;
        final int endLine;
        final int beginColumn;
        final int endColumn;
        curTokenImage= input_stream.getImage();
        beginLine= input_stream.getBeginLine();
        beginColumn= input_stream.getBeginColumn();
        endLine= input_stream.getEndLine();
        endColumn= input_stream.getEndColumn();
        t= Token.newToken(TokenType.values()[jjmatchedKind], curTokenImage, this);
        t.setBeginLine(beginLine);
        t.setEndLine(endLine);
        t.setBeginColumn(beginColumn);
        t.setEndColumn(endColumn);
        //        t.setInputSource(this.inputSource);
        return t;
    }

    private void jjCheckNAdd(int state) {
        if (jjrounds[state]!=jjround) {
            jjstateSet[jjnewStateCnt++]= state;
            jjrounds[state]= jjround;
        }
    }

    private void jjAddStates(int start, int end) {
        do {
            jjstateSet[jjnewStateCnt++]= jjnextStates[start];
        }
        while (start++!=end);
    }

    private void jjCheckNAddTwoStates(int state1, int state2) {
        jjCheckNAdd(state1);
        jjCheckNAdd(state2);
    }

    private void jjCheckNAddStates(int start, int end) {
        do {
            jjCheckNAdd(jjnextStates[start]);
        }
        while (start++!=end);
    }

    private void jjCheckNAddStates(int start) {
        jjCheckNAdd(jjnextStates[start]);
        jjCheckNAdd(jjnextStates[start+1]);
    }

    private int jjStopAtPos(int pos, int kind) {
        jjmatchedKind= kind;
        jjmatchedPos= pos;
        if (trace_enabled) LOGGER.info("   No more string literal token matches are possible.");
        if (trace_enabled) LOGGER.info("   Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token.");
        return pos+1;
    }

    private int jjStartNfa(int pos, long active0, long active1) {
        return jjMoveNfa(jjStopStringLiteralDfa(pos, active0, active1), pos+1);
    }

    private final int jjStopStringLiteralDfa(int pos, long active0, long active1) {
        if (trace_enabled) LOGGER.info("   No more string literal token matches are possible.");
        switch(pos) {
            case 0:
            if ((active0&0xc003e003f7c00000L)!=0L||(active1&0x7fL)!=0L) {
                jjmatchedKind= 59;
                return 17;
            }
            if ((active0&0x80000000000L)!=0L) return 9;
            if ((active0&0x40000000000L)!=0L||(active1&0xf80L)!=0L) return 12;
            if ((active0&0x8000000L)!=0L) {
                jjmatchedKind= 59;
                return 2;
            }
            return-1;
            case 1:
            if ((active0&0x2000000L)!=0L) return 17;
            if ((active0&0xc003e003fdc00000L)!=0L||(active1&0x7fL)!=0L) {
                jjmatchedKind= 59;
                jjmatchedPos= 1;
                return 17;
            }
            return-1;
            case 2:
            if ((active0&0x200200000000L)!=0L) return 17;
            if ((active0&0xc003c001fdc00000L)!=0L||(active1&0x7fL)!=0L) {
                jjmatchedKind= 59;
                jjmatchedPos= 2;
                return 17;
            }
            return-1;
            case 3:
            if ((active0&0x80004d800000L)!=0L) return 17;
            if ((active0&0xc0034001b0400000L)!=0L||(active1&0x7fL)!=0L) {
                jjmatchedKind= 59;
                jjmatchedPos= 3;
                return 17;
            }
            return-1;
            case 4:
            if ((active0&0x100000000L)!=0L) return 17;
            if ((active0&0xc0034000b0400000L)!=0L||(active1&0x7fL)!=0L) {
                jjmatchedKind= 59;
                jjmatchedPos= 4;
                return 17;
            }
            return-1;
            case 5:
            if ((active0&0x2400020400000L)!=0L) return 17;
            if ((active0&0xc001000090000000L)!=0L||(active1&0x7fL)!=0L) {
                jjmatchedKind= 59;
                jjmatchedPos= 5;
                return 17;
            }
            return-1;
            case 6:
            if ((active0&0x1000090000000L)!=0L) return 17;
            if ((active0&0xc000000000000000L)!=0L||(active1&0x7fL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 7:
            if ((active0&0xc000000000000000L)!=0L||(active1&0x7fL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 8:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x7fL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 9:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x7fL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 10:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x7fL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 11:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x7dL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 12:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x7dL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 13:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x7dL)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 14:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x79L)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 15:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x69L)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 16:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x68L)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            case 17:
            if ((active0&0x4000000000000000L)!=0L||(active1&0x20L)!=0L) {
                if (jjmatchedPos<5) {
                    jjmatchedKind= 59;
                    jjmatchedPos= 5;
                }
                return-1;
            }
            return-1;
            default:
            return-1;
        }
    }

    private int jjStartNfaWithStates(int pos, int kind, int state) {
        jjmatchedKind= kind;
        jjmatchedPos= pos;
        if (trace_enabled) LOGGER.info("   No more string literal token matches are possible.");
        if (trace_enabled) LOGGER.info("   Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token.");
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            return pos+1;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") "+"at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        return jjMoveNfa(state, pos+1);
    }

    private int jjMoveStringLiteralDfa0() {
        switch(curChar) {
            case 33:
            jjmatchedKind= 20;
            return jjMoveStringLiteralDfa1(0x1000L, 0x0L);
            case 37:
            return jjStopAtPos(0, 9);
            case 38:
            return jjMoveStringLiteralDfa1(0x40000L, 0x0L);
            case 39:
            return jjStartNfaWithStates(0, 43, 9);
            case 40:
            return jjStopAtPos(0, 34);
            case 41:
            return jjStopAtPos(0, 35);
            case 42:
            return jjStopAtPos(0, 7);
            case 43:
            return jjStopAtPos(0, 5);
            case 44:
            return jjStopAtPos(0, 41);
            case 45:
            return jjStopAtPos(0, 6);
            case 46:
            jjmatchedKind= 42;
            return jjMoveStringLiteralDfa1(0x0L, 0xf80L);
            case 47:
            return jjStopAtPos(0, 8);
            case 58:
            return jjStopAtPos(0, 17);
            case 59:
            return jjStopAtPos(0, 40);
            case 60:
            jjmatchedKind= 16;
            return jjMoveStringLiteralDfa1(0x4000L, 0x0L);
            case 61:
            jjmatchedKind= 10;
            return jjMoveStringLiteralDfa1(0x800L, 0x0L);
            case 62:
            jjmatchedKind= 15;
            return jjMoveStringLiteralDfa1(0x2000L, 0x0L);
            case 64:
            return jjStopAtPos(0, 44);
            case 66:
            return jjMoveStringLiteralDfa1(0x180000000L, 0x0L);
            case 67:
            return jjMoveStringLiteralDfa1(0x40000000L, 0x0L);
            case 68:
            return jjMoveStringLiteralDfa1(0x20000000L, 0x0L);
            case 69:
            return jjMoveStringLiteralDfa1(0x200000000L, 0x0L);
            case 73:
            return jjMoveStringLiteralDfa1(0x10000000L, 0x0L);
            case 83:
            return jjMoveStringLiteralDfa1(0x4002000000000000L, 0x7fL);
            case 91:
            return jjStopAtPos(0, 38);
            case 93:
            return jjStopAtPos(0, 39);
            case 94:
            return jjStopAtPos(0, 21);
            case 98:
            return jjMoveStringLiteralDfa1(0x1000000000000L, 0x0L);
            case 99:
            return jjMoveStringLiteralDfa1(0x800000000000L, 0x0L);
            case 100:
            return jjMoveStringLiteralDfa1(0x400000000000L, 0x0L);
            case 101:
            return jjMoveStringLiteralDfa1(0x4000000L, 0x0L);
            case 105:
            return jjMoveStringLiteralDfa1(0x200002000000L, 0x0L);
            case 108:
            return jjMoveStringLiteralDfa1(0x8000000000000000L, 0x0L);
            case 110:
            return jjMoveStringLiteralDfa1(0x1000000L, 0x0L);
            case 114:
            return jjMoveStringLiteralDfa1(0x400000L, 0x0L);
            case 116:
            return jjMoveStringLiteralDfa1(0x8000000L, 0x0L);
            case 118:
            return jjMoveStringLiteralDfa1(0x800000L, 0x0L);
            case 123:
            return jjStopAtPos(0, 36);
            case 124:
            return jjMoveStringLiteralDfa1(0x80000L, 0x0L);
            case 125:
            return jjStopAtPos(0, 37);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            return jjMoveNfa(3, 0);
        }
    }

    private int jjMoveStringLiteralDfa1(long active0, long active1) {
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(0, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 1;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 38:
            if ((active0&0x40000L)!=0L) return jjStopAtPos(1, 18);
            break;
            case 61:
            if ((active0&0x800L)!=0L) return jjStopAtPos(1, 11);
            else if ((active0&0x1000L)!=0L) return jjStopAtPos(1, 12);
            else if ((active0&0x2000L)!=0L) return jjStopAtPos(1, 13);
            else if ((active0&0x4000L)!=0L) return jjStopAtPos(1, 14);
            break;
            case 101:
            return jjMoveStringLiteralDfa2(active0, 0x8000000100400000L, active1, 0x0L);
            case 102:
            if ((active0&0x2000000L)!=0L) return jjStartNfaWithStates(1, 25, 17);
            break;
            case 104:
            return jjMoveStringLiteralDfa2(active0, 0x800048000000L, active1, 0x0L);
            case 105:
            return jjMoveStringLiteralDfa2(active0, 0x0L, active1, 0x300L);
            case 108:
            return jjMoveStringLiteralDfa2(active0, 0x4000000L, active1, 0x80L);
            case 110:
            return jjMoveStringLiteralDfa2(active0, 0x200210000000L, active1, 0x0L);
            case 111:
            return jjMoveStringLiteralDfa2(active0, 0x14000a0800000L, active1, 0x0L);
            case 116:
            return jjMoveStringLiteralDfa2(active0, 0x2000000000000L, active1, 0xc00L);
            case 117:
            return jjMoveStringLiteralDfa2(active0, 0x1000000L, active1, 0x0L);
            case 121:
            return jjMoveStringLiteralDfa2(active0, 0x4000000000000000L, active1, 0x7fL);
            case 124:
            if ((active0&0x80000L)!=0L) return jjStopAtPos(1, 19);
            break;
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(0, active0, active1);
    }

    private int jjMoveStringLiteralDfa2(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(0, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(1, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 2;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 97:
            return jjMoveStringLiteralDfa3(active0, 0x800040000000L, active1, 0x0L);
            case 100:
            if ((active0&0x200000000L)!=0L) return jjStartNfaWithStates(2, 33, 17);
            break;
            case 101:
            return jjMoveStringLiteralDfa3(active0, 0x0L, active1, 0x80L);
            case 103:
            return jjMoveStringLiteralDfa3(active0, 0x100000000L, active1, 0x0L);
            case 105:
            return jjMoveStringLiteralDfa3(active0, 0x8800000L, active1, 0x0L);
            case 108:
            return jjMoveStringLiteralDfa3(active0, 0x1000000L, active1, 0x0L);
            case 110:
            return jjMoveStringLiteralDfa3(active0, 0x8000000000000000L, active1, 0x0L);
            case 111:
            return jjMoveStringLiteralDfa3(active0, 0x1000080000000L, active1, 0xc00L);
            case 114:
            return jjMoveStringLiteralDfa3(active0, 0x2000000000000L, active1, 0x0L);
            case 115:
            return jjMoveStringLiteralDfa3(active0, 0x4000000004000000L, active1, 0x37fL);
            case 116:
            if ((active0&0x200000000000L)!=0L) return jjStartNfaWithStates(2, 45, 17);
            return jjMoveStringLiteralDfa3(active0, 0x10400000L, active1, 0x0L);
            case 117:
            return jjMoveStringLiteralDfa3(active0, 0x400020000000L, active1, 0x0L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(1, active0, active1);
    }

    private int jjMoveStringLiteralDfa3(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(1, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(2, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 3;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 68:
            return jjMoveStringLiteralDfa4(active0, 0x0L, active1, 0xa00L);
            case 73:
            return jjMoveStringLiteralDfa4(active0, 0x0L, active1, 0x500L);
            case 98:
            return jjMoveStringLiteralDfa4(active0, 0x400020000000L, active1, 0x0L);
            case 100:
            if ((active0&0x800000L)!=0L) return jjStartNfaWithStates(3, 23, 17);
            break;
            case 101:
            if ((active0&0x4000000L)!=0L) return jjStartNfaWithStates(3, 26, 17);
            return jjMoveStringLiteralDfa4(active0, 0x10000000L, active1, 0x0L);
            case 103:
            return jjMoveStringLiteralDfa4(active0, 0x8000000000000000L, active1, 0x0L);
            case 105:
            return jjMoveStringLiteralDfa4(active0, 0x2000100000000L, active1, 0x0L);
            case 108:
            if ((active0&0x1000000L)!=0L) return jjStartNfaWithStates(3, 24, 17);
            return jjMoveStringLiteralDfa4(active0, 0x1000080000000L, active1, 0x0L);
            case 110:
            return jjMoveStringLiteralDfa4(active0, 0x0L, active1, 0x80L);
            case 114:
            if ((active0&0x40000000L)!=0L) return jjStartNfaWithStates(3, 30, 17);
            else if ((active0&0x800000000000L)!=0L) return jjStartNfaWithStates(3, 47, 17);
            break;
            case 115:
            if ((active0&0x8000000L)!=0L) return jjStartNfaWithStates(3, 27, 17);
            break;
            case 116:
            return jjMoveStringLiteralDfa4(active0, 0x4000000000000000L, active1, 0x7fL);
            case 117:
            return jjMoveStringLiteralDfa4(active0, 0x400000L, active1, 0x0L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(2, active0, active1);
    }

    private int jjMoveStringLiteralDfa4(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(2, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(3, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 4;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 101:
            return jjMoveStringLiteralDfa5(active0, 0x4001000080000000L, active1, 0x7fL);
            case 103:
            return jjMoveStringLiteralDfa5(active0, 0x10000000L, active1, 0x80L);
            case 108:
            return jjMoveStringLiteralDfa5(active0, 0x400020000000L, active1, 0x0L);
            case 110:
            if ((active0&0x100000000L)!=0L) return jjStartNfaWithStates(4, 32, 17);
            return jjMoveStringLiteralDfa5(active0, 0x2000000000000L, active1, 0x500L);
            case 111:
            return jjMoveStringLiteralDfa5(active0, 0x0L, active1, 0xa00L);
            case 114:
            return jjMoveStringLiteralDfa5(active0, 0x400000L, active1, 0x0L);
            case 116:
            return jjMoveStringLiteralDfa5(active0, 0x8000000000000000L, active1, 0x0L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(3, active0, active1);
    }

    private int jjMoveStringLiteralDfa5(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(3, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(4, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 5;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 97:
            return jjMoveStringLiteralDfa6(active0, 0x1000080000000L, active1, 0x0L);
            case 101:
            if ((active0&0x20000000L)!=0L) return jjStartNfaWithStates(5, 29, 17);
            else if ((active0&0x400000000000L)!=0L) return jjStartNfaWithStates(5, 46, 17);
            return jjMoveStringLiteralDfa6(active0, 0x10000000L, active1, 0x0L);
            case 103:
            if ((active0&0x2000000000000L)!=0L) return jjStartNfaWithStates(5, 49, 17);
            break;
            case 104:
            return jjMoveStringLiteralDfa6(active0, 0x8000000000000000L, active1, 0x0L);
            case 109:
            return jjMoveStringLiteralDfa6(active0, 0x4000000000000000L, active1, 0x7fL);
            case 110:
            if ((active0&0x400000L)!=0L) return jjStartNfaWithStates(5, 22, 17);
            break;
            case 116:
            return jjMoveStringLiteralDfa6(active0, 0x0L, active1, 0x580L);
            case 117:
            return jjMoveStringLiteralDfa6(active0, 0x0L, active1, 0xa00L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(4, active0, active1);
    }

    private int jjMoveStringLiteralDfa6(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(4, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(5, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 6;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 40:
            return jjMoveStringLiteralDfa7(active0, 0x8000000000000000L, active1, 0x500L);
            case 46:
            return jjMoveStringLiteralDfa7(active0, 0x4000000000000000L, active1, 0x7fL);
            case 98:
            return jjMoveStringLiteralDfa7(active0, 0x0L, active1, 0xa00L);
            case 104:
            return jjMoveStringLiteralDfa7(active0, 0x0L, active1, 0x80L);
            case 110:
            if ((active0&0x80000000L)!=0L) return jjStartNfaWithStates(6, 31, 17);
            else if ((active0&0x1000000000000L)!=0L) return jjStartNfaWithStates(6, 48, 17);
            break;
            case 114:
            if ((active0&0x10000000L)!=0L) return jjStartNfaWithStates(6, 28, 17);
            break;
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(5, active0, active1);
    }

    private int jjMoveStringLiteralDfa7(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(5, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(6, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 7;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 40:
            return jjMoveStringLiteralDfa8(active0, 0x0L, active1, 0x80L);
            case 41:
            if ((active0&0x8000000000000000L)!=0L) return jjStopAtPos(7, 63);
            else if ((active1&0x100L)!=0L) return jjStopAtPos(7, 72);
            else if ((active1&0x400L)!=0L) return jjStopAtPos(7, 74);
            break;
            case 108:
            return jjMoveStringLiteralDfa8(active0, 0x0L, active1, 0xa00L);
            case 110:
            return jjMoveStringLiteralDfa8(active0, 0x0L, active1, 0x7eL);
            case 111:
            return jjMoveStringLiteralDfa8(active0, 0x4000000000000000L, active1, 0x1L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(6, active0, active1);
    }

    private int jjMoveStringLiteralDfa8(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(6, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(7, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 8;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 41:
            if ((active1&0x80L)!=0L) return jjStopAtPos(8, 71);
            break;
            case 101:
            return jjMoveStringLiteralDfa9(active0, 0x0L, active1, 0xa7eL);
            case 117:
            return jjMoveStringLiteralDfa9(active0, 0x4000000000000000L, active1, 0x1L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(7, active0, active1);
    }

    private int jjMoveStringLiteralDfa9(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(7, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(8, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 9;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 40:
            return jjMoveStringLiteralDfa10(active0, 0x0L, active1, 0xa00L);
            case 116:
            return jjMoveStringLiteralDfa10(active0, 0x4000000000000000L, active1, 0x1L);
            case 120:
            return jjMoveStringLiteralDfa10(active0, 0x0L, active1, 0x7eL);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(8, active0, active1);
    }

    private int jjMoveStringLiteralDfa10(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(8, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(9, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 10;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 41:
            if ((active1&0x200L)!=0L) return jjStopAtPos(10, 73);
            else if ((active1&0x800L)!=0L) return jjStopAtPos(10, 75);
            break;
            case 46:
            return jjMoveStringLiteralDfa11(active0, 0x4000000000000000L, active1, 0x1L);
            case 116:
            if ((active1&0x2L)!=0L) {
                jjmatchedKind= 65;
                jjmatchedPos= 10;
            }
            return jjMoveStringLiteralDfa11(active0, 0x0L, active1, 0x7cL);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(9, active0, active1);
    }

    private int jjMoveStringLiteralDfa11(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(9, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(10, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 11;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 66:
            return jjMoveStringLiteralDfa12(active0, 0x0L, active1, 0x20L);
            case 67:
            return jjMoveStringLiteralDfa12(active0, 0x0L, active1, 0x10L);
            case 68:
            return jjMoveStringLiteralDfa12(active0, 0x0L, active1, 0x8L);
            case 73:
            return jjMoveStringLiteralDfa12(active0, 0x0L, active1, 0x4L);
            case 83:
            return jjMoveStringLiteralDfa12(active0, 0x0L, active1, 0x40L);
            case 112:
            return jjMoveStringLiteralDfa12(active0, 0x4000000000000000L, active1, 0x1L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(10, active0, active1);
    }

    private int jjMoveStringLiteralDfa12(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(10, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(11, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 12;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 104:
            return jjMoveStringLiteralDfa13(active0, 0x0L, active1, 0x10L);
            case 110:
            return jjMoveStringLiteralDfa13(active0, 0x0L, active1, 0x4L);
            case 111:
            return jjMoveStringLiteralDfa13(active0, 0x0L, active1, 0x28L);
            case 114:
            return jjMoveStringLiteralDfa13(active0, 0x4000000000000000L, active1, 0x1L);
            case 116:
            return jjMoveStringLiteralDfa13(active0, 0x0L, active1, 0x40L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(11, active0, active1);
    }

    private int jjMoveStringLiteralDfa13(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(11, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(12, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 13;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 97:
            return jjMoveStringLiteralDfa14(active0, 0x0L, active1, 0x10L);
            case 105:
            return jjMoveStringLiteralDfa14(active0, 0x4000000000000000L, active1, 0x1L);
            case 111:
            return jjMoveStringLiteralDfa14(active0, 0x0L, active1, 0x20L);
            case 114:
            return jjMoveStringLiteralDfa14(active0, 0x0L, active1, 0x40L);
            case 116:
            if ((active1&0x4L)!=0L) return jjStopAtPos(13, 66);
            break;
            case 117:
            return jjMoveStringLiteralDfa14(active0, 0x0L, active1, 0x8L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(12, active0, active1);
    }

    private int jjMoveStringLiteralDfa14(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(12, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(13, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 14;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 98:
            return jjMoveStringLiteralDfa15(active0, 0x0L, active1, 0x8L);
            case 105:
            return jjMoveStringLiteralDfa15(active0, 0x0L, active1, 0x40L);
            case 108:
            return jjMoveStringLiteralDfa15(active0, 0x0L, active1, 0x20L);
            case 110:
            return jjMoveStringLiteralDfa15(active0, 0x4000000000000000L, active1, 0x1L);
            case 114:
            if ((active1&0x10L)!=0L) return jjStopAtPos(14, 68);
            break;
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(13, active0, active1);
    }

    private int jjMoveStringLiteralDfa15(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(13, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(14, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 15;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 101:
            return jjMoveStringLiteralDfa16(active0, 0x0L, active1, 0x20L);
            case 108:
            return jjMoveStringLiteralDfa16(active0, 0x0L, active1, 0x8L);
            case 110:
            return jjMoveStringLiteralDfa16(active0, 0x0L, active1, 0x40L);
            case 116:
            if ((active1&0x1L)!=0L) {
                jjmatchedKind= 64;
                jjmatchedPos= 15;
            }
            return jjMoveStringLiteralDfa16(active0, 0x4000000000000000L, active1, 0x0L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(14, active0, active1);
    }

    private int jjMoveStringLiteralDfa16(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(14, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(15, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 16;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 97:
            return jjMoveStringLiteralDfa17(active0, 0x0L, active1, 0x20L);
            case 101:
            if ((active1&0x8L)!=0L) return jjStopAtPos(16, 67);
            break;
            case 103:
            if ((active1&0x40L)!=0L) return jjStopAtPos(16, 70);
            break;
            case 108:
            return jjMoveStringLiteralDfa17(active0, 0x4000000000000000L, active1, 0x0L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(15, active0, active1);
    }

    private int jjMoveStringLiteralDfa17(long old0, long active0, long old1, long active1) {
        active0= active0&old0;
        active1= active1&old1;
        if ((active0|active1)== 0L) return jjStartNfa(15, old0, old1);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa(16, active0, active1);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 17;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 110:
            if ((active0&0x4000000000000000L)!=0L) return jjStopAtPos(17, 62);
            else if ((active1&0x20L)!=0L) return jjStopAtPos(17, 69);
            break;
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa(16, active0, active1);
    }

    private int jjMoveNfa(int startState, int curPos) {
        int startsAt= 0;
        jjnewStateCnt= 46;
        int i= 1;
        jjstateSet[0]= startState;
        int kind= 0x7fffffff;
        while (true) {
            if (++jjround== 0x7fffffff) {
                ReInitRounds();
            }
            if (curChar<64) {
                long l= 1L<<curChar;
                do {
                    switch(jjstateSet[--i]) {
                        case 3:
                        if ((0x3ff000000000000L&l)!=0L) {
                            if (kind> 57) kind= 57;
                            jjAddStates(0, 4);
                        }
                        else if (curChar== 34) jjAddStates(5, 8);
                        else if (curChar== 46) jjstateSet[jjnewStateCnt++]= 12;
                        else if (curChar== 39) jjstateSet[jjnewStateCnt++]= 9;
                        break;
                        case 2:
                        case 17:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 59) kind= 59;
                        jjCheckNAdd(17);
                        break;
                        case 8:
                        if (curChar== 39) jjCheckNAdd(9);
                        break;
                        case 9:
                        if ((0x3ff000000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 10;
                        break;
                        case 10:
                        if (curChar== 39&&kind> 56) kind= 56;
                        break;
                        case 11:
                        if (curChar== 46) jjCheckNAdd(12);
                        break;
                        case 12:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 58) kind= 58;
                        jjCheckNAddTwoStates(12, 13);
                        break;
                        case 14:
                        if ((0x280000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 15;
                        break;
                        case 15:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 58) kind= 58;
                        jjCheckNAdd(15);
                        break;
                        case 18:
                        if (curChar== 34) jjCheckNAddStates(5, 8);
                        break;
                        case 19:
                        if (curChar== 46) jjstateSet[jjnewStateCnt++]= 20;
                        break;
                        case 20:
                        if ((0x3ff000000000000L&l)!=0L) jjAddStates(9, 13);
                        break;
                        case 22:
                        if ((0x280000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 23;
                        break;
                        case 23:
                        if ((0x3ff000000000000L&l)!=0L) jjAddStates(14, 17);
                        break;
                        case 24:
                        if ((0x3ff000100000000L&l)!=0L) jjCheckNAddStates(5, 8);
                        break;
                        case 25:
                        if (curChar== 34&&kind> 60) kind= 60;
                        break;
                        case 26:
                        if ((0x3ff000000000000L&l)!=0L) jjAddStates(18, 21);
                        break;
                        case 27:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddTwoStates(27, 28);
                        break;
                        case 28:
                        if (curChar== 46) jjAddStates(22, 26);
                        break;
                        case 30:
                        if ((0x280000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 31;
                        break;
                        case 31:
                        if ((0x3ff000000000000L&l)!=0L) jjAddStates(27, 30);
                        break;
                        case 32:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddStates(31, 37);
                        break;
                        case 33:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddTwoStates(33, 19);
                        break;
                        case 34:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddStates(38, 45);
                        break;
                        case 35:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddStates(46, 52);
                        break;
                        case 36:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddStates(53, 60);
                        break;
                        case 37:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 57) kind= 57;
                        jjCheckNAddStates(0, 4);
                        break;
                        case 38:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 57) kind= 57;
                        jjCheckNAdd(38);
                        break;
                        case 39:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddTwoStates(39, 40);
                        break;
                        case 40:
                        if (curChar!=46) break;
                        if (kind> 58) kind= 58;
                        jjAddStates(61, 62);
                        break;
                        case 41:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 58) kind= 58;
                        jjCheckNAddTwoStates(41, 42);
                        break;
                        case 43:
                        if ((0x280000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 44;
                        break;
                        case 44:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 58) kind= 58;
                        jjCheckNAdd(44);
                        break;
                        case 45:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddTwoStates(45, 11);
                        break;
                        default:
                        break;
                    }
                }
                while (i!=startsAt);
            }
            else if (curChar<128) {
                long l= 1L<<(curChar&077);
                do {
                    switch(jjstateSet[--i]) {
                        case 3:
                        if ((0x7fffffe87fffffeL&l)!=0L) {
                            if (kind> 59) kind= 59;
                            jjstateSet[jjnewStateCnt++]= 17;
                        }
                        if (curChar== 102) jjstateSet[jjnewStateCnt++]= 6;
                        else if (curChar== 116) jjstateSet[jjnewStateCnt++]= 2;
                        break;
                        case 2:
                        if ((0x7fffffe87fffffeL&l)!=0L) {
                            if (kind> 59) kind= 59;
                            jjCheckNAdd(17);
                        }
                        if (curChar== 114) jjstateSet[jjnewStateCnt++]= 1;
                        break;
                        case 0:
                        if (curChar== 101&&kind> 55) kind= 55;
                        break;
                        case 1:
                        if (curChar== 117) jjstateSet[jjnewStateCnt++]= 0;
                        break;
                        case 4:
                        if (curChar== 115) jjstateSet[jjnewStateCnt++]= 0;
                        break;
                        case 5:
                        if (curChar== 108) jjstateSet[jjnewStateCnt++]= 4;
                        break;
                        case 6:
                        if (curChar== 97) jjstateSet[jjnewStateCnt++]= 5;
                        break;
                        case 7:
                        if (curChar== 102) jjCheckNAdd(6);
                        break;
                        case 9:
                        if ((0x7fffffe87fffffeL&l)!=0L) jjstateSet[jjnewStateCnt++]= 10;
                        break;
                        case 13:
                        if ((0x2000000020L&l)!=0L) jjAddStates(63, 64);
                        break;
                        case 16:
                        if ((0x7fffffe87fffffeL&l)== 0L) break;
                        if (kind> 59) kind= 59;
                        jjCheckNAdd(17);
                        break;
                        case 17:
                        if ((0x7fffffe87fffffeL&l)== 0L) break;
                        if (kind> 59) kind= 59;
                        jjCheckNAdd(17);
                        break;
                        case 21:
                        if ((0x2000000020L&l)!=0L) jjAddStates(65, 66);
                        break;
                        case 24:
                        if ((0x7fffffe87fffffeL&l)!=0L) jjCheckNAddStates(5, 8);
                        break;
                        case 29:
                        if ((0x2000000020L&l)!=0L) jjAddStates(67, 68);
                        break;
                        case 42:
                        if ((0x2000000020L&l)!=0L) jjAddStates(69, 70);
                        break;
                        default:
                        break;
                    }
                }
                while (i!=startsAt);
            }
            else {
                int hiByte= (int)(curChar>>8);
                int i1= hiByte>>6;
                long l1= 1L<<(hiByte&077);
                int i2= (curChar&0xff)>>6;
                long l2= 1L<<(curChar&077);
                do {
                    switch(jjstateSet[--i]) {
                        default:
                        break;
                    }
                }
                while (i!=startsAt);
            }
            if (kind!=0x7fffffff) {
                jjmatchedKind= kind;
                jjmatchedPos= curPos;
                kind= 0x7fffffff;
            }
            ++curPos;
            if (jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                if (trace_enabled) LOGGER.info("   Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token.");
            }
            if ((i= jjnewStateCnt)== (startsAt= 46-(jjnewStateCnt= startsAt))) return curPos;
            int retval= input_stream.readChar();
            if (retval>=0) {
                curChar= (char) retval;
            }
            else {
                return curPos;
            }
            if (trace_enabled) LOGGER.info(""+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") "+"at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        }
    }

    private static final int[] jjnextStates= {38, 39, 40, 45, 11, 19, 24, 25, 26, 19, 21, 24, 25, 36, 19, 24, 25, 35, 27, 28, 33, 19, 29, 19, 24, 25, 34, 19, 24, 25, 32, 27, 28, 33, 19, 24, 25, 32, 27, 28, 29, 33, 19, 24, 25, 34, 27, 28, 33, 19, 24, 25, 35, 27, 28, 33, 19, 21, 24, 25, 36, 41, 42, 14, 15, 22, 23, 30, 31, 43, 44};
}
