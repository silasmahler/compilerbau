/* Generated by: JavaCC 21 Parser Generator. NewAwkParser.java */
package de.compilerbau.NewAwkCompiler.javacc21;

import java.util.*;
import java.util.concurrent.CancellationException;
import java.util.logging.*;
import java.io.*;
import static de.compilerbau.NewAwkCompiler.javacc21.NewAwkConstants.TokenType.*;
import de.compilerbau.NewAwkCompiler.Visitors.*;
import de.compilerbau.NewAwkCompiler.javacc21.*;
@SuppressWarnings("unused")
public class NewAwkParser implements NewAwkConstants {
    private static final org.slf4j.Logger log= org.slf4j.LoggerFactory.getLogger(NewAwkParser.class);
    static public ArrayList<Node> roots= new ArrayList<> ();
    public static void main(String[] args) throws ParseException, FileNotFoundException {
        System.err.println("Arguments: "+args.length);
        for (String s : args) {
            System.err.println("Arg: "+s);
        }
        List<File> failures= new ArrayList<File> ();
        List<File> successes= new ArrayList<File> ();
        boolean failureOccurred= false;
        NewAwkParser parser;
        if (args.length== 0) {
            usage();
        }
        List<File> files= new ArrayList<File> ();
        for (String arg : args) {
            File file= new File(arg);
            if (!file.exists()) {
                System.err.println("File "+file+" does not exist.");
                continue;
            }
            addFilesRecursively(files, file);
        }
        long startTime= System.currentTimeMillis();
        for (File file : files) {
            try {
                // A bit screwball, we'll dump the tree if there is only one arg. :-)
                parseFile(file, files.size()>=1);
            }
            catch(Exception e) {
                System.err.println("Error processing file: "+file);
                e.printStackTrace();
                failures.add(file);
                continue;
            }
            System.out.println(file.getName()+" parsed successfully.");
            successes.add(file);
        }
        for (File file : failures) {
            System.out.println("Parse failed on: "+file);
        }
        System.out.println("\nParsed "+successes.size()+" files successfully");
        System.out.println("Failed on "+failures.size()+" files.");
        System.out.println("\nDuration: "+(System.currentTimeMillis()-startTime)+" milliseconds");
    }

    static public void parseFile(File file, boolean dumpTree) throws IOException, ParseException {
        FileReader fr= new FileReader(file);
        NewAwkParser parser= new NewAwkParser(fr);
        parser.setInputSource(file.toString());
        Node root= parser.CompilationUnit();
        // Uncomment the following code if you want all the parsed trees
        //  to remain in memory. This is useful if you want to know how much
        //  memory it takes to parse all the source code in the JDK, for example.
        //  (About 8GB if we're talking about JDK 13)
        //       roots.add(root);
        //       if (roots.size() % 1000 == 0) {
        //            System.out.println("-----------------------------------------------");
        //            System.out.println("Parsed "  +  roots.size() + " files.");
        //            System.out.println("-----------------------------------------------");
        //       }
        if (dumpTree) {
            Nodes.dump(root, ">");
            DumpVisitor dumpVisitor= new DumpVisitor();
            SymbolTableBuilderVisitor symbolTableBuilderVisitor= new SymbolTableBuilderVisitor();
            if (root instanceof CompilationUnit) {
                System.out.println("Entering Visitors...");
                //((CompilationUnit) root).jjtAccept(dumpVisitor, null);
                ((CompilationUnit) root).jjtAccept(symbolTableBuilderVisitor, null);
            }
        }
    }

    static public void addFilesRecursively(List<File> files, File file) {
        if (file.isDirectory()) {
            for (File f : file.listFiles()) {
                addFilesRecursively(files, f);
            }
        }
        else if (file.getName().endsWith("java")&&!file.getName().endsWith("-info.java")||file.getName().endsWith("txt")&&!file.getName().endsWith("-info.java")) {
            files.add(file);
        }
    }

    static public void usage() {
        System.out.println("Usage: java JParse <sourcefiles or directories>");
        System.out.println("If you just pass it one java source file, it dumps the AST");
        System.exit(-1);
    }

    private static final java.util.logging.Logger LOGGER= Logger.getLogger(NewAwkParser.class.getName());
    public static void setLogLevel(Level level) {
        LOGGER.setLevel(level);
        Logger.getGlobal().getParent().getHandlers()[0].setLevel(level);
    }

    static final int UNLIMITED= Integer.MAX_VALUE;
    // The last token successfully "consumed"     
    Token currentToken;
    private TokenType nextTokenType;
    private Token currentLookaheadToken;
    private int remainingLookahead;
    // private TokenType upToTokenType;
    // private EnumSet<TokenType> upToFirstSet;
    private boolean stopAtScanLimit;
    private Token lastParsedToken;
    //private Token nextToken; //REVISIT
    //private EnumSet<Token> currentFollowSet;
    private boolean cancelled;
    public void cancel() {
        cancelled= true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** Generated Lexer. */
    public NewAwkLexer token_source;
    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    //=================================
    // Generated constructors
    //=================================
    public NewAwkParser(String inputSource, CharSequence content) {
        this(new NewAwkLexer(inputSource, content));
    }

    public NewAwkParser(CharSequence content) {
        this("input", content);
    }

    public NewAwkParser(java.io.InputStream stream) {
        this(new InputStreamReader(stream));
    }

    public NewAwkParser(Reader reader) {
        this(new NewAwkLexer(reader));
    }

    /** Constructor with user supplied Lexer. */
    public NewAwkParser(NewAwkLexer lexer) {
        token_source= lexer;
        currentToken= new Token();
    }

    final public Token getNextToken() {
        if (currentToken.getNext()!=null) currentToken= currentToken.getNext();
        else {
            Token nextToken= token_source.getNextToken();
            currentToken.setNext(nextToken);
            currentToken= nextToken;
        }
        return currentToken;
    }

    /** Get the specific Token index ahead in the stream. */
    final public Token getToken(int index) {
        Token t= currentToken;
        for (int i= 0; i<index; i++) {
            if (t.getNext()!=null) t= t.getNext();
            else {
                Token nextToken= token_source.getNextToken();
                t.setNext(nextToken);
                t= nextToken;
            }
        }
        return t;
    }

    private final boolean setNextTokenType() {
        if (currentToken.getNext()== null) {
            Token nextToken= token_source.getNextToken();
            currentToken.setNext(nextToken);
        }
        nextTokenType= currentToken.getNext().getType();
        return true;
    }

    private final TokenType nextTokenType() {
        setNextTokenType();
        return nextTokenType;
    }

    /*
    ==============================================================================================
    Parser Rules and AST generation are defined/handled in this section
    ==============================================================================================
*/
    // NewAwkParser.jjt, line 206
    final public Node CompilationUnit() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 206 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean CompilationUnit1forced= false;
        CompilationUnit CompilationUnit1= null;
        if (buildTree) {
            CompilationUnit1= new CompilationUnit();
            openNodeScope(CompilationUnit1);
        }
        ParseException parseException1= null;
        int callStackSize1= parsingStack.size();
        try {
            // Code for OneOrMore specified on line 207 of NewAwkParser.jjt
            boolean inFirst0= true;
            do {
                // Code for ExpansionChoice specified on line 207 of NewAwkParser.jjt
                if (scan$NewAwkParser_jjt$line_207$column_6()) {
                    // Code for NonTerminal specified on line 207 of NewAwkParser.jjt
                    pushOntoCallStack("CompilationUnit", "NewAwkParser.jjt", 207, 20);
                    try {
                        VariableDecl();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (scan$NewAwkParser_jjt$line_208$column_6()) {
                    // Code for NonTerminal specified on line 208 of NewAwkParser.jjt
                    pushOntoCallStack("CompilationUnit", "NewAwkParser.jjt", 208, 19);
                    try {
                        Assignement();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (scan$NewAwkParser_jjt$line_209$column_6()) {
                    // Code for NonTerminal specified on line 209 of NewAwkParser.jjt
                    pushOntoCallStack("CompilationUnit", "NewAwkParser.jjt", 209, 19);
                    try {
                        VariableDeclAndAssignement();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (first_set$NewAwkParser_jjt$line_210$column_6.contains(nextTokenType())) {
                    // Code for NonTerminal specified on line 210 of NewAwkParser.jjt
                    pushOntoCallStack("CompilationUnit", "NewAwkParser.jjt", 210, 6);
                    try {
                        MethodDecl();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (inFirst0) {
                    pushOntoCallStack("CompilationUnit", "NewAwkParser.jjt", 207, 6);
                    throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_207$column_6, parsingStack);
                }
                else {
                    break;
                }
                inFirst0= false;
            }
            while (true);
            // Code for EndOfFile specified on line 211 of NewAwkParser.jjt
            consumeToken(EOF);
            // Code for CodeBlock specified on line 212 of NewAwkParser.jjt
            return CompilationUnit1;
        }
        catch(ParseException e) {
            parseException1= e;
            throw e;
        }
        finally {
            if (parseException1== null) {
                restoreCallStack(callStackSize1);
            }
            if (buildTree) {
                if (parseException1== null) {
                    closeNodeScope(CompilationUnit1, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException1.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 213
    final public void VariableDecl() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 213 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean VariableDecl2forced= false;
        VariableDecl VariableDecl2= null;
        if (buildTree) {
            VariableDecl2= new VariableDecl();
            openNodeScope(VariableDecl2);
        }
        ParseException parseException2= null;
        int callStackSize2= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 213 of NewAwkParser.jjt
            pushOntoCallStack("VariableDecl", "NewAwkParser.jjt", 213, 30);
            try {
                Type();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 213 of NewAwkParser.jjt
            consumeToken(ID);
            // Code for RegexpRef specified on line 213 of NewAwkParser.jjt
            consumeToken(SEMICOLON);
            if (trace_enabled) LOGGER.info("Exiting normally from VariableDecl");
        }
        catch(ParseException e) {
            parseException2= e;
            throw e;
        }
        finally {
            if (parseException2== null) {
                restoreCallStack(callStackSize2);
            }
            if (buildTree) {
                if (parseException2== null) {
                    closeNodeScope(VariableDecl2, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException2.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 214
    final public void Assignement() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 214 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Assignement3forced= false;
        Assignement Assignement3= null;
        if (buildTree) {
            Assignement3= new Assignement();
            openNodeScope(Assignement3);
        }
        ParseException parseException3= null;
        int callStackSize3= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 214 of NewAwkParser.jjt
            consumeToken(ID);
            // Code for RegexpRef specified on line 214 of NewAwkParser.jjt
            consumeToken(Zuweisung);
            // Code for NonTerminal specified on line 214 of NewAwkParser.jjt
            pushOntoCallStack("Assignement", "NewAwkParser.jjt", 214, 44);
            try {
                ExprStmnt();
            }
            finally {
                popCallStack();
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Assignement");
        }
        catch(ParseException e) {
            parseException3= e;
            throw e;
        }
        finally {
            if (parseException3== null) {
                restoreCallStack(callStackSize3);
            }
            if (buildTree) {
                if (parseException3== null) {
                    closeNodeScope(Assignement3, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException3.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 215
    final public void VariableDeclAndAssignement() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 215 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean VariableDeclAndAssignement4forced= false;
        VariableDeclAndAssignement VariableDeclAndAssignement4= null;
        if (buildTree) {
            VariableDeclAndAssignement4= new VariableDeclAndAssignement();
            openNodeScope(VariableDeclAndAssignement4);
        }
        ParseException parseException4= null;
        int callStackSize4= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 216 of NewAwkParser.jjt
            pushOntoCallStack("VariableDeclAndAssignement", "NewAwkParser.jjt", 216, 5);
            try {
                Type();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 216 of NewAwkParser.jjt
            consumeToken(ID);
            // Code for RegexpRef specified on line 216 of NewAwkParser.jjt
            consumeToken(Zuweisung);
            // Code for NonTerminal specified on line 216 of NewAwkParser.jjt
            pushOntoCallStack("VariableDeclAndAssignement", "NewAwkParser.jjt", 216, 27);
            try {
                ExprStmnt();
            }
            finally {
                popCallStack();
            }
            if (trace_enabled) LOGGER.info("Exiting normally from VariableDeclAndAssignement");
        }
        catch(ParseException e) {
            parseException4= e;
            throw e;
        }
        finally {
            if (parseException4== null) {
                restoreCallStack(callStackSize4);
            }
            if (buildTree) {
                if (parseException4== null) {
                    closeNodeScope(VariableDeclAndAssignement4, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException4.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 217
    final public void MethodDecl() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 217 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean MethodDecl5forced= false;
        MethodDecl MethodDecl5= null;
        if (buildTree) {
            MethodDecl5= new MethodDecl();
            openNodeScope(MethodDecl5);
        }
        ParseException parseException5= null;
        int callStackSize5= parsingStack.size();
        Token t;
        try {
            // Code for ExpansionChoice specified on line 218 of NewAwkParser.jjt
            if (first_set$NewAwkParser_jjt$line_218$column_6.contains(nextTokenType())) {
                // Code for NonTerminal specified on line 218 of NewAwkParser.jjt
                pushOntoCallStack("MethodDecl", "NewAwkParser.jjt", 218, 6);
                try {
                    Type();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== VOID) {
                // Code for RegexpRef specified on line 218 of NewAwkParser.jjt
                consumeToken(VOID);
                // Code for CodeBlock specified on line 218 of NewAwkParser.jjt
                MethodDecl5.isVoid= true;
            }
            else {
                pushOntoCallStack("MethodDecl", "NewAwkParser.jjt", 218, 6);
                throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_218$column_6$, parsingStack);
            }
            // Code for RegexpRef specified on line 219 of NewAwkParser.jjt
            consumeToken(ID);
            // Code for RegexpRef specified on line 219 of NewAwkParser.jjt
            consumeToken(KlammerAuf);
            // Code for NonTerminal specified on line 219 of NewAwkParser.jjt
            pushOntoCallStack("MethodDecl", "NewAwkParser.jjt", 219, 23);
            try {
                ParameterList();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 219 of NewAwkParser.jjt
            consumeToken(KlammerZu);
            // Code for NonTerminal specified on line 219 of NewAwkParser.jjt
            pushOntoCallStack("MethodDecl", "NewAwkParser.jjt", 219, 49);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
            if (trace_enabled) LOGGER.info("Exiting normally from MethodDecl");
        }
        catch(ParseException e) {
            parseException5= e;
            throw e;
        }
        finally {
            if (parseException5== null) {
                restoreCallStack(callStackSize5);
            }
            if (buildTree) {
                if (parseException5== null) {
                    closeNodeScope(MethodDecl5, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException5.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 220
    final public void ParameterList() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 220 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean ParameterList6forced= false;
        ParameterList ParameterList6= null;
        if (buildTree) {
            ParameterList6= new ParameterList();
            openNodeScope(ParameterList6);
        }
        ParseException parseException6= null;
        int callStackSize6= parsingStack.size();
        try {
            // Code for ZeroOrOne specified on line 220 of NewAwkParser.jjt
            if (first_set$NewAwkParser_jjt$line_220$column_33.contains(nextTokenType())) {
                // Code for NonTerminal specified on line 220 of NewAwkParser.jjt
                pushOntoCallStack("ParameterList", "NewAwkParser.jjt", 220, 33);
                try {
                    Type();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpRef specified on line 220 of NewAwkParser.jjt
                consumeToken(ID);
            }
            // Code for ZeroOrMore specified on line 220 of NewAwkParser.jjt
            while (nextTokenType()== COMMA) {
                // Code for RegexpRef specified on line 220 of NewAwkParser.jjt
                consumeToken(COMMA);
                // Code for NonTerminal specified on line 220 of NewAwkParser.jjt
                pushOntoCallStack("ParameterList", "NewAwkParser.jjt", 220, 53);
                try {
                    Type();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpRef specified on line 220 of NewAwkParser.jjt
                consumeToken(ID);
            }
            if (trace_enabled) LOGGER.info("Exiting normally from ParameterList");
        }
        catch(ParseException e) {
            parseException6= e;
            throw e;
        }
        finally {
            if (parseException6== null) {
                restoreCallStack(callStackSize6);
            }
            if (buildTree) {
                if (parseException6== null) {
                    closeNodeScope(ParameterList6, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException6.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 221
    final public void Stmnt() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 221 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Stmnt7forced= false;
        Stmnt Stmnt7= null;
        if (buildTree) {
            Stmnt7= new Stmnt();
            openNodeScope(Stmnt7);
        }
        ParseException parseException7= null;
        int callStackSize7= parsingStack.size();
        try {
            // Code for AttemptBlock specified on line 222 of NewAwkParser.jjt
            try {
                stashParseState();
                // Code for ExpansionChoice specified on line 223 of NewAwkParser.jjt
                if (nextTokenType()== BlockAuf) {
                    // Code for NonTerminal specified on line 223 of NewAwkParser.jjt
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 223, 6);
                    try {
                        Block();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (nextTokenType()== IF) {
                    // Code for NonTerminal specified on line 223 of NewAwkParser.jjt
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 223, 14);
                    try {
                        IfStmnt();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (nextTokenType()== RETURN) {
                    // Code for NonTerminal specified on line 223 of NewAwkParser.jjt
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 223, 24);
                    try {
                        ReturnStmnt();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (nextTokenType()== PRINT_LINE||nextTokenType== PRINT) {
                    // Code for NonTerminal specified on line 223 of NewAwkParser.jjt
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 223, 38);
                    try {
                        PrintStmnt();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (scan$NewAwkParser_jjt$line_224$column_8()) {
                    // Code for NonTerminal specified on line 224 of NewAwkParser.jjt
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 224, 18);
                    try {
                        VariableDecl();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (scan$NewAwkParser_jjt$line_225$column_8()) {
                    // Code for NonTerminal specified on line 225 of NewAwkParser.jjt
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 225, 18);
                    try {
                        Assignement();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (scan$NewAwkParser_jjt$line_226$column_8()) {
                    // Code for NonTerminal specified on line 226 of NewAwkParser.jjt
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 226, 18);
                    try {
                        VariableDeclAndAssignement();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else {
                    pushOntoCallStack("Stmnt", "NewAwkParser.jjt", 223, 6);
                    throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_223$column_6, parsingStack);
                }
                popParseState();
            }
            catch(ParseException e) {
                restoreStashedParseState();
                log.error("Encoutered Syntax-Error in Stmnt: Attempting Recovery (Assuming a Semicolon is missing)!");
                Token t;
                int counter= 0;
                do {
                    t= getNextToken();
                    log.info("Skipping Token: "+t.getImage());
                    counter++;
                }
                while (//!t.equals(";")
                !t.getImage().equals(";")&&counter<=50000);
                log.info("Successfully recovered missing simicolon!");
                if (counter== 50000) {
                    log.warn("Beware that the compiler checked the next 50.000 Tokens. It could be that your missing Semicolon is the last and you reached and of file.");
                }
                if (false) throw new ParseException("Never happens!");
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Stmnt");
        }
        catch(ParseException e) {
            parseException7= e;
            throw e;
        }
        finally {
            if (parseException7== null) {
                restoreCallStack(callStackSize7);
            }
            if (buildTree) {
                if (parseException7== null) {
                    closeNodeScope(Stmnt7, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException7.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 244
    final public void Block() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 244 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Block8forced= false;
        Block Block8= null;
        if (buildTree) {
            Block8= new Block();
            openNodeScope(Block8);
        }
        ParseException parseException8= null;
        int callStackSize8= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 244 of NewAwkParser.jjt
            consumeToken(BlockAuf);
            // Code for OneOrMore specified on line 244 of NewAwkParser.jjt
            do {
                // Code for NonTerminal specified on line 244 of NewAwkParser.jjt
                pushOntoCallStack("Block", "NewAwkParser.jjt", 244, 34);
                try {
                    Stmnt();
                }
                finally {
                    popCallStack();
                }
            }
            while (first_set$NewAwkParser_jjt$line_244$column_34.contains(nextTokenType()));
            // Code for RegexpRef specified on line 244 of NewAwkParser.jjt
            consumeToken(BlockZu);
            if (trace_enabled) LOGGER.info("Exiting normally from Block");
        }
        catch(ParseException e) {
            parseException8= e;
            throw e;
        }
        finally {
            if (parseException8== null) {
                restoreCallStack(callStackSize8);
            }
            if (buildTree) {
                if (parseException8== null) {
                    closeNodeScope(Block8, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException8.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 245
    final public void IfStmnt() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 245 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean IfStmnt9forced= false;
        IfStmnt IfStmnt9= null;
        if (buildTree) {
            IfStmnt9= new IfStmnt();
            openNodeScope(IfStmnt9);
        }
        ParseException parseException9= null;
        int callStackSize9= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 245 of NewAwkParser.jjt
            consumeToken(IF);
            // Code for RegexpRef specified on line 245 of NewAwkParser.jjt
            consumeToken(KlammerAuf);
            // Code for NonTerminal specified on line 245 of NewAwkParser.jjt
            pushOntoCallStack("IfStmnt", "NewAwkParser.jjt", 245, 42);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 245 of NewAwkParser.jjt
            consumeToken(KlammerZu);
            // Code for NonTerminal specified on line 245 of NewAwkParser.jjt
            pushOntoCallStack("IfStmnt", "NewAwkParser.jjt", 245, 59);
            try {
                Stmnt();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified on line 245 of NewAwkParser.jjt
            while (nextTokenType()== ELSE) {
                // Code for RegexpRef specified on line 245 of NewAwkParser.jjt
                consumeToken(ELSE);
                // Code for NonTerminal specified on line 245 of NewAwkParser.jjt
                pushOntoCallStack("IfStmnt", "NewAwkParser.jjt", 245, 73);
                try {
                    Stmnt();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpRef specified on line 245 of NewAwkParser.jjt
            consumeToken(SEMICOLON);
            if (trace_enabled) LOGGER.info("Exiting normally from IfStmnt");
        }
        catch(ParseException e) {
            parseException9= e;
            throw e;
        }
        finally {
            if (parseException9== null) {
                restoreCallStack(callStackSize9);
            }
            if (buildTree) {
                if (parseException9== null) {
                    closeNodeScope(IfStmnt9, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException9.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 246
    final public void ExprStmnt() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 246 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean ExprStmnt10forced= false;
        ExprStmnt ExprStmnt10= null;
        if (buildTree) {
            ExprStmnt10= new ExprStmnt();
            openNodeScope(ExprStmnt10);
        }
        ParseException parseException10= null;
        int callStackSize10= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 246 of NewAwkParser.jjt
            pushOntoCallStack("ExprStmnt", "NewAwkParser.jjt", 246, 25);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 246 of NewAwkParser.jjt
            consumeToken(SEMICOLON);
            if (trace_enabled) LOGGER.info("Exiting normally from ExprStmnt");
        }
        catch(ParseException e) {
            parseException10= e;
            throw e;
        }
        finally {
            if (parseException10== null) {
                restoreCallStack(callStackSize10);
            }
            if (buildTree) {
                if (parseException10== null) {
                    closeNodeScope(ExprStmnt10, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException10.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 247
    final public void Expr() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 247 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Expr11forced= false;
        Expr Expr11= null;
        if (buildTree) {
            Expr11= new Expr();
            openNodeScope(Expr11);
        }
        ParseException parseException11= null;
        int callStackSize11= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 247 of NewAwkParser.jjt
            pushOntoCallStack("Expr", "NewAwkParser.jjt", 247, 21);
            try {
                LogicalOrExpr();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified on line 247 of NewAwkParser.jjt
            while (nextTokenType()== Zuweisung) {
                // Code for RegexpRef specified on line 247 of NewAwkParser.jjt
                consumeToken(Zuweisung);
                // Code for NonTerminal specified on line 247 of NewAwkParser.jjt
                pushOntoCallStack("Expr", "NewAwkParser.jjt", 247, 49);
                try {
                    LogicalOrExpr();
                }
                finally {
                    popCallStack();
                }
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Expr");
        }
        catch(ParseException e) {
            parseException11= e;
            throw e;
        }
        finally {
            if (parseException11== null) {
                restoreCallStack(callStackSize11);
            }
            if (buildTree) {
                if (parseException11== null) {
                    closeNodeScope(Expr11, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException11.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 248
    final public void LogicalOrExpr() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 248 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean LogicalOrExpr12forced= false;
        LogicalOrExpr LogicalOrExpr12= null;
        if (buildTree) {
            LogicalOrExpr12= new LogicalOrExpr();
            openNodeScope(LogicalOrExpr12);
        }
        ParseException parseException12= null;
        int callStackSize12= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 248 of NewAwkParser.jjt
            pushOntoCallStack("LogicalOrExpr", "NewAwkParser.jjt", 248, 33);
            try {
                LogicalAndExpr();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified on line 248 of NewAwkParser.jjt
            while (nextTokenType()== ConditionalOr) {
                // Code for RegexpRef specified on line 248 of NewAwkParser.jjt
                consumeToken(ConditionalOr);
                // Code for NonTerminal specified on line 248 of NewAwkParser.jjt
                pushOntoCallStack("LogicalOrExpr", "NewAwkParser.jjt", 248, 65);
                try {
                    LogicalAndExpr();
                }
                finally {
                    popCallStack();
                }
            }
            if (trace_enabled) LOGGER.info("Exiting normally from LogicalOrExpr");
        }
        catch(ParseException e) {
            parseException12= e;
            throw e;
        }
        finally {
            if (parseException12== null) {
                restoreCallStack(callStackSize12);
            }
            if (buildTree) {
                if (parseException12== null) {
                    closeNodeScope(LogicalOrExpr12, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException12.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 249
    final public void LogicalAndExpr() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 249 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean LogicalAndExpr13forced= false;
        LogicalAndExpr LogicalAndExpr13= null;
        if (buildTree) {
            LogicalAndExpr13= new LogicalAndExpr();
            openNodeScope(LogicalAndExpr13);
        }
        ParseException parseException13= null;
        int callStackSize13= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 249 of NewAwkParser.jjt
            pushOntoCallStack("LogicalAndExpr", "NewAwkParser.jjt", 249, 34);
            try {
                LogicalNotExpr();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified on line 249 of NewAwkParser.jjt
            while (nextTokenType()== ConditionalAnd) {
                // Code for RegexpRef specified on line 249 of NewAwkParser.jjt
                consumeToken(ConditionalAnd);
                // Code for NonTerminal specified on line 249 of NewAwkParser.jjt
                pushOntoCallStack("LogicalAndExpr", "NewAwkParser.jjt", 249, 67);
                try {
                    LogicalNotExpr();
                }
                finally {
                    popCallStack();
                }
            }
            if (trace_enabled) LOGGER.info("Exiting normally from LogicalAndExpr");
        }
        catch(ParseException e) {
            parseException13= e;
            throw e;
        }
        finally {
            if (parseException13== null) {
                restoreCallStack(callStackSize13);
            }
            if (buildTree) {
                if (parseException13== null) {
                    closeNodeScope(LogicalAndExpr13, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException13.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 250
    final public void LogicalNotExpr() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 250 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean LogicalNotExpr14forced= false;
        LogicalNotExpr LogicalNotExpr14= null;
        if (buildTree) {
            LogicalNotExpr14= new LogicalNotExpr();
            openNodeScope(LogicalNotExpr14);
        }
        ParseException parseException14= null;
        int callStackSize14= parsingStack.size();
        try {
            // Code for ZeroOrMore specified on line 250 of NewAwkParser.jjt
            while (nextTokenType()== ConditionalNot) {
                // Code for RegexpRef specified on line 250 of NewAwkParser.jjt
                consumeToken(ConditionalNot);
            }
            // Code for NonTerminal specified on line 250 of NewAwkParser.jjt
            pushOntoCallStack("LogicalNotExpr", "NewAwkParser.jjt", 250, 54);
            try {
                CompExpr();
            }
            finally {
                popCallStack();
            }
            if (trace_enabled) LOGGER.info("Exiting normally from LogicalNotExpr");
        }
        catch(ParseException e) {
            parseException14= e;
            throw e;
        }
        finally {
            if (parseException14== null) {
                restoreCallStack(callStackSize14);
            }
            if (buildTree) {
                if (parseException14== null) {
                    closeNodeScope(LogicalNotExpr14, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException14.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 251
    final public void CompExpr() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 251 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean CompExpr15forced= false;
        CompExpr CompExpr15= null;
        if (buildTree) {
            CompExpr15= new CompExpr();
            openNodeScope(CompExpr15);
        }
        ParseException parseException15= null;
        int callStackSize15= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 251 of NewAwkParser.jjt
            pushOntoCallStack("CompExpr", "NewAwkParser.jjt", 251, 28);
            try {
                Sum();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified on line 251 of NewAwkParser.jjt
            while (first_set$NewAwkParser_jjt$line_251$column_33.contains(nextTokenType())) {
                // Code for ExpansionChoice specified on line 251 of NewAwkParser.jjt
                if (nextTokenType()== GREATER) {
                    // Code for RegexpRef specified on line 251 of NewAwkParser.jjt
                    consumeToken(GREATER);
                }
                else if (nextTokenType()== SMALLER) {
                    // Code for RegexpRef specified on line 251 of NewAwkParser.jjt
                    consumeToken(SMALLER);
                }
                else if (nextTokenType()== S_OR_EQUAL) {
                    // Code for RegexpRef specified on line 251 of NewAwkParser.jjt
                    consumeToken(S_OR_EQUAL);
                }
                else if (nextTokenType()== G_OR_EQUAL) {
                    // Code for RegexpRef specified on line 251 of NewAwkParser.jjt
                    consumeToken(G_OR_EQUAL);
                }
                else if (nextTokenType()== EQUAL) {
                    // Code for RegexpRef specified on line 251 of NewAwkParser.jjt
                    consumeToken(EQUAL);
                }
                else if (nextTokenType()== NOT_EQUAL) {
                    // Code for RegexpRef specified on line 251 of NewAwkParser.jjt
                    consumeToken(NOT_EQUAL);
                }
                else {
                    pushOntoCallStack("CompExpr", "NewAwkParser.jjt", 251, 34);
                    throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_251$column_34, parsingStack);
                }
                // Code for NonTerminal specified on line 251 of NewAwkParser.jjt
                pushOntoCallStack("CompExpr", "NewAwkParser.jjt", 251, 111);
                try {
                    Sum();
                }
                finally {
                    popCallStack();
                }
            }
            if (trace_enabled) LOGGER.info("Exiting normally from CompExpr");
        }
        catch(ParseException e) {
            parseException15= e;
            throw e;
        }
        finally {
            if (parseException15== null) {
                restoreCallStack(callStackSize15);
            }
            if (buildTree) {
                if (parseException15== null) {
                    closeNodeScope(CompExpr15, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException15.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 252
    final public void Sum() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 252 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Sum16forced= false;
        Sum Sum16= null;
        if (buildTree) {
            Sum16= new Sum();
            openNodeScope(Sum16);
        }
        ParseException parseException16= null;
        int callStackSize16= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 252 of NewAwkParser.jjt
            pushOntoCallStack("Sum", "NewAwkParser.jjt", 252, 23);
            try {
                Product();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified on line 252 of NewAwkParser.jjt
            while (nextTokenType()== PLUS||nextTokenType== MINUS) {
                // Code for ExpansionChoice specified on line 252 of NewAwkParser.jjt
                if (nextTokenType()== PLUS) {
                    // Code for RegexpRef specified on line 252 of NewAwkParser.jjt
                    consumeToken(PLUS);
                }
                else if (nextTokenType()== MINUS) {
                    // Code for RegexpRef specified on line 252 of NewAwkParser.jjt
                    consumeToken(MINUS);
                }
                else {
                    pushOntoCallStack("Sum", "NewAwkParser.jjt", 252, 33);
                    throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_252$column_33, parsingStack);
                }
                // Code for NonTerminal specified on line 252 of NewAwkParser.jjt
                pushOntoCallStack("Sum", "NewAwkParser.jjt", 252, 52);
                try {
                    Product();
                }
                finally {
                    popCallStack();
                }
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Sum");
        }
        catch(ParseException e) {
            parseException16= e;
            throw e;
        }
        finally {
            if (parseException16== null) {
                restoreCallStack(callStackSize16);
            }
            if (buildTree) {
                if (parseException16== null) {
                    closeNodeScope(Sum16, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException16.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 253
    final public void Product() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 253 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Product17forced= false;
        Product Product17= null;
        if (buildTree) {
            Product17= new Product();
            openNodeScope(Product17);
        }
        ParseException parseException17= null;
        int callStackSize17= parsingStack.size();
        try {
            // Code for NonTerminal specified on line 253 of NewAwkParser.jjt
            pushOntoCallStack("Product", "NewAwkParser.jjt", 253, 27);
            try {
                Sign();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified on line 253 of NewAwkParser.jjt
            while (nextTokenType()== MULTIPLICATION||nextTokenType== DIVISION||nextTokenType== MODULO) {
                // Code for ExpansionChoice specified on line 253 of NewAwkParser.jjt
                if (nextTokenType()== MULTIPLICATION) {
                    // Code for RegexpRef specified on line 253 of NewAwkParser.jjt
                    consumeToken(MULTIPLICATION);
                }
                else if (nextTokenType()== DIVISION) {
                    // Code for RegexpRef specified on line 253 of NewAwkParser.jjt
                    consumeToken(DIVISION);
                }
                else if (nextTokenType()== MODULO) {
                    // Code for RegexpRef specified on line 253 of NewAwkParser.jjt
                    consumeToken(MODULO);
                }
                else {
                    pushOntoCallStack("Product", "NewAwkParser.jjt", 253, 34);
                    throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_253$column_34, parsingStack);
                }
                // Code for NonTerminal specified on line 253 of NewAwkParser.jjt
                pushOntoCallStack("Product", "NewAwkParser.jjt", 253, 76);
                try {
                    Sign();
                }
                finally {
                    popCallStack();
                }
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Product");
        }
        catch(ParseException e) {
            parseException17= e;
            throw e;
        }
        finally {
            if (parseException17== null) {
                restoreCallStack(callStackSize17);
            }
            if (buildTree) {
                if (parseException17== null) {
                    closeNodeScope(Product17, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException17.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    static private final EnumSet<TokenType> Sign_FIRST_SET= EnumSet.of(PLUS, MINUS, NullLiteral, KlammerAuf, BlockAuf, BooleanLiteral, CharLiteral, IntegerLiteral, DoubleLiteral, ID, StringLiteral, PRINT_LINE, PRINT, NEXT, NEXT_INT, NEXT_DOUBLE, NEXT_CHAR, NEXT_BOOLEAN, NEXT_STRING);
    // NewAwkParser.jjt, line 254
    final public void Sign() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 254 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        // Code for ExpansionChoice specified on line 254 of NewAwkParser.jjt
        boolean Sign18forced= false;
        Sign Sign18= null;
        if (buildTree) {
            Sign18= new Sign();
            openNodeScope(Sign18);
        }
        ParseException parseException18= null;
        int callStackSize18= parsingStack.size();
        try {
            if (first_set$NewAwkParser_jjt$line_254$column_23.contains(nextTokenType())) {
                // Code for NonTerminal specified on line 254 of NewAwkParser.jjt
                pushOntoCallStack("Sign", "NewAwkParser.jjt", 254, 23);
                try {
                    Atom();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== PLUS||nextTokenType== MINUS) {
                // Code for ExpansionChoice specified on line 254 of NewAwkParser.jjt
                if (nextTokenType()== PLUS) {
                    // Code for RegexpRef specified on line 254 of NewAwkParser.jjt
                    consumeToken(PLUS);
                }
                else if (nextTokenType()== MINUS) {
                    // Code for RegexpRef specified on line 254 of NewAwkParser.jjt
                    consumeToken(MINUS);
                }
                else {
                    pushOntoCallStack("Sign", "NewAwkParser.jjt", 254, 31);
                    throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_254$column_31, parsingStack);
                }
                // Code for NonTerminal specified on line 254 of NewAwkParser.jjt
                pushOntoCallStack("Sign", "NewAwkParser.jjt", 254, 50);
                try {
                    Atom();
                }
                finally {
                    popCallStack();
                }
            }
            else {
                pushOntoCallStack("Sign", "NewAwkParser.jjt", 254, 23);
                throw new ParseException(currentToken.getNext(), Sign_FIRST_SET, parsingStack);
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Sign");
        }
        catch(ParseException e) {
            parseException18= e;
            throw e;
        }
        finally {
            if (parseException18== null) {
                restoreCallStack(callStackSize18);
            }
            if (buildTree) {
                if (parseException18== null) {
                    closeNodeScope(Sign18, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException18.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 255
    final public void Atom() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 255 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Atom19forced= false;
        Atom Atom19= null;
        if (buildTree) {
            Atom19= new Atom();
            openNodeScope(Atom19);
        }
        ParseException parseException19= null;
        int callStackSize19= parsingStack.size();
        Token t;
        try {
            // Code for ExpansionChoice specified on line 256 of NewAwkParser.jjt
            if (first_set$NewAwkParser_jjt$line_256$column_6.contains(nextTokenType())) {
                // Code for NonTerminal specified on line 256 of NewAwkParser.jjt
                pushOntoCallStack("Atom", "NewAwkParser.jjt", 256, 6);
                try {
                    NextStmnt();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== PRINT_LINE||nextTokenType== PRINT) {
                // Code for NonTerminal specified on line 256 of NewAwkParser.jjt
                pushOntoCallStack("Atom", "NewAwkParser.jjt", 256, 18);
                try {
                    PrintStmnt();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$NewAwkParser_jjt$line_256$column_31()) {
                // Code for NonTerminal specified on line 256 of NewAwkParser.jjt
                pushOntoCallStack("Atom", "NewAwkParser.jjt", 256, 41);
                try {
                    KlammerAffe();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== ID) {
                // Code for RegexpRef specified on line 257 of NewAwkParser.jjt
                consumeToken(ID);
                // Code for ZeroOrMore specified on line 258 of NewAwkParser.jjt
                while (nextTokenType()== ArrayAuf) {
                    // Code for NonTerminal specified on line 258 of NewAwkParser.jjt
                    pushOntoCallStack("Atom", "NewAwkParser.jjt", 258, 10);
                    try {
                        ArrayAccess();
                    }
                    finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified on line 259 of NewAwkParser.jjt
                    Atom19.isArrayAccess= true;
                    Atom19.arrayAccessDimension++;
                }
                // Code for ZeroOrOne specified on line 262 of NewAwkParser.jjt
                if (nextTokenType()== _TOKEN_71) {
                    // Code for RegexpStringLiteral specified on line 262 of NewAwkParser.jjt
                    consumeToken(_TOKEN_71);
                    // Code for CodeBlock specified on line 262 of NewAwkParser.jjt
                    Atom19.hasLength= true;
                }
            }
            else if (nextTokenType()== BlockAuf) {
                // Code for RegexpRef specified on line 263 of NewAwkParser.jjt
                consumeToken(BlockAuf);
                // Code for NonTerminal specified on line 263 of NewAwkParser.jjt
                pushOntoCallStack("Atom", "NewAwkParser.jjt", 263, 18);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified on line 264 of NewAwkParser.jjt
                while (nextTokenType()== COMMA) {
                    // Code for RegexpRef specified on line 264 of NewAwkParser.jjt
                    consumeToken(COMMA);
                    // Code for NonTerminal specified on line 264 of NewAwkParser.jjt
                    pushOntoCallStack("Atom", "NewAwkParser.jjt", 264, 18);
                    try {
                        Expr();
                    }
                    finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified on line 265 of NewAwkParser.jjt
                    Atom19.isArrayInit= true;
                }
                // Code for RegexpRef specified on line 267 of NewAwkParser.jjt
                consumeToken(BlockZu);
                // Code for CodeBlock specified on line 268 of NewAwkParser.jjt
                Atom19.isArrayInit= true;
            }
            else if (nextTokenType()== KlammerAuf) {
                // Code for RegexpRef specified on line 269 of NewAwkParser.jjt
                consumeToken(KlammerAuf);
                // Code for NonTerminal specified on line 269 of NewAwkParser.jjt
                pushOntoCallStack("Atom", "NewAwkParser.jjt", 269, 20);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpRef specified on line 269 of NewAwkParser.jjt
                consumeToken(KlammerZu);
                // Code for CodeBlock specified on line 270 of NewAwkParser.jjt
                Atom19.isExpression= true;
            }
            else if (nextTokenType()== BooleanLiteral) {
                // Code for RegexpRef specified on line 271 of NewAwkParser.jjt
                t= consumeToken(BooleanLiteral);
                // Code for CodeBlock specified on line 272 of NewAwkParser.jjt
                Atom19.type= new Type("boolean");
                Atom19.value= t.getImage();
            }
            else if (nextTokenType()== IntegerLiteral) {
                // Code for RegexpRef specified on line 274 of NewAwkParser.jjt
                t= consumeToken(IntegerLiteral);
                // Code for CodeBlock specified on line 275 of NewAwkParser.jjt
                Atom19.type= new Type("int");
                Atom19.value= t.getImage();
            }
            else if (nextTokenType()== DoubleLiteral) {
                // Code for RegexpRef specified on line 277 of NewAwkParser.jjt
                t= consumeToken(DoubleLiteral);
                // Code for CodeBlock specified on line 278 of NewAwkParser.jjt
                Atom19.type= new Type("double");
                Atom19.value= t.getImage();
            }
            else if (nextTokenType()== CharLiteral) {
                // Code for RegexpRef specified on line 280 of NewAwkParser.jjt
                t= consumeToken(CharLiteral);
                // Code for CodeBlock specified on line 281 of NewAwkParser.jjt
                Atom19.type= new Type("char");
                Atom19.value= t.getImage();
            }
            else if (nextTokenType()== NullLiteral) {
                // Code for RegexpRef specified on line 283 of NewAwkParser.jjt
                t= consumeToken(NullLiteral);
            }
            else if (scan$NewAwkParser_jjt$line_284$column_7()) {
                // Code for RegexpRef specified on line 284 of NewAwkParser.jjt
                t= consumeToken(StringLiteral);
                // Code for ZeroOrOne specified on line 285 of NewAwkParser.jjt
                if (first_set$NewAwkParser_jjt$line_285$column_10.contains(nextTokenType())) {
                    // Code for ExpansionChoice specified on line 285 of NewAwkParser.jjt
                    if (nextTokenType()== _TOKEN_71) {
                        // Code for RegexpStringLiteral specified on line 285 of NewAwkParser.jjt
                        consumeToken(_TOKEN_71);
                        // Code for CodeBlock specified on line 285 of NewAwkParser.jjt
                        Atom19.hasLength= true;
                        Atom19.atomLength= t.getImage().length();
                    }
                    else if (nextTokenType()== _TOKEN_72) {
                        // Code for RegexpStringLiteral specified on line 287 of NewAwkParser.jjt
                        consumeToken(_TOKEN_72);
                        // Code for CodeBlock specified on line 287 of NewAwkParser.jjt
                        Atom19.isInt= true;
                    }
                    else if (nextTokenType()== _TOKEN_73) {
                        // Code for RegexpStringLiteral specified on line 288 of NewAwkParser.jjt
                        consumeToken(_TOKEN_73);
                        // Code for CodeBlock specified on line 288 of NewAwkParser.jjt
                        Atom19.isDouble= true;
                    }
                    else if (nextTokenType()== _TOKEN_74) {
                        // Code for RegexpStringLiteral specified on line 289 of NewAwkParser.jjt
                        consumeToken(_TOKEN_74);
                        // Code for CodeBlock specified on line 289 of NewAwkParser.jjt
                        Atom19.toInt= true;
                    }
                    else if (nextTokenType()== _TOKEN_75) {
                        // Code for RegexpStringLiteral specified on line 290 of NewAwkParser.jjt
                        consumeToken(_TOKEN_75);
                        // Code for CodeBlock specified on line 290 of NewAwkParser.jjt
                        Atom19.toDouble= true;
                    }
                    else {
                        pushOntoCallStack("Atom", "NewAwkParser.jjt", 285, 11);
                        throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_285$column_11, parsingStack);
                    }
                }
            }
            else {
                pushOntoCallStack("Atom", "NewAwkParser.jjt", 256, 6);
                throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_256$column_6$, parsingStack);
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Atom");
        }
        catch(ParseException e) {
            parseException19= e;
            throw e;
        }
        finally {
            if (parseException19== null) {
                restoreCallStack(callStackSize19);
            }
            if (buildTree) {
                if (parseException19== null) {
                    closeNodeScope(Atom19, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException19.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 293
    final public void MethodCall() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 293 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean MethodCall20forced= false;
        MethodCall MethodCall20= null;
        if (buildTree) {
            MethodCall20= new MethodCall();
            openNodeScope(MethodCall20);
        }
        ParseException parseException20= null;
        int callStackSize20= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 293 of NewAwkParser.jjt
            consumeToken(ID);
            // Code for RegexpRef specified on line 293 of NewAwkParser.jjt
            consumeToken(KlammerAuf);
            // Code for ZeroOrOne specified on line 293 of NewAwkParser.jjt
            if (first_set$NewAwkParser_jjt$line_293$column_45.contains(nextTokenType())) {
                // Code for NonTerminal specified on line 293 of NewAwkParser.jjt
                pushOntoCallStack("MethodCall", "NewAwkParser.jjt", 293, 45);
                try {
                    Expr();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified on line 293 of NewAwkParser.jjt
                while (nextTokenType()== COMMA) {
                    // Code for RegexpRef specified on line 293 of NewAwkParser.jjt
                    consumeToken(COMMA);
                    // Code for NonTerminal specified on line 293 of NewAwkParser.jjt
                    pushOntoCallStack("MethodCall", "NewAwkParser.jjt", 293, 59);
                    try {
                        Expr();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            // Code for RegexpRef specified on line 293 of NewAwkParser.jjt
            consumeToken(KlammerZu);
            if (trace_enabled) LOGGER.info("Exiting normally from MethodCall");
        }
        catch(ParseException e) {
            parseException20= e;
            throw e;
        }
        finally {
            if (parseException20== null) {
                restoreCallStack(callStackSize20);
            }
            if (buildTree) {
                if (parseException20== null) {
                    closeNodeScope(MethodCall20, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException20.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 294
    final public void ArrayAccess() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 294 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean ArrayAccess21forced= false;
        ArrayAccess ArrayAccess21= null;
        if (buildTree) {
            ArrayAccess21= new ArrayAccess();
            openNodeScope(ArrayAccess21);
        }
        ParseException parseException21= null;
        int callStackSize21= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 294 of NewAwkParser.jjt
            consumeToken(ArrayAuf);
            // Code for NonTerminal specified on line 294 of NewAwkParser.jjt
            pushOntoCallStack("ArrayAccess", "NewAwkParser.jjt", 294, 39);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 294 of NewAwkParser.jjt
            consumeToken(ArrayZu);
            if (trace_enabled) LOGGER.info("Exiting normally from ArrayAccess");
        }
        catch(ParseException e) {
            parseException21= e;
            throw e;
        }
        finally {
            if (parseException21== null) {
                restoreCallStack(callStackSize21);
            }
            if (buildTree) {
                if (parseException21== null) {
                    closeNodeScope(ArrayAccess21, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException21.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 295
    final public void Type() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 295 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean Type22forced= false;
        Type Type22= null;
        if (buildTree) {
            Type22= new Type();
            openNodeScope(Type22);
        }
        ParseException parseException22= null;
        int callStackSize22= parsingStack.size();
        Token t;
        try {
            // Code for ExpansionChoice specified on line 296 of NewAwkParser.jjt
            if (nextTokenType()== TypeInt) {
                // Code for RegexpRef specified on line 296 of NewAwkParser.jjt
                t= consumeToken(TypeInt);
            }
            else if (nextTokenType()== TypeDouble) {
                // Code for RegexpRef specified on line 296 of NewAwkParser.jjt
                t= consumeToken(TypeDouble);
            }
            else if (nextTokenType()== TypeChar) {
                // Code for RegexpRef specified on line 296 of NewAwkParser.jjt
                t= consumeToken(TypeChar);
            }
            else if (nextTokenType()== TypeBoolean) {
                // Code for RegexpRef specified on line 296 of NewAwkParser.jjt
                t= consumeToken(TypeBoolean);
            }
            else if (nextTokenType()== TypeString) {
                // Code for RegexpRef specified on line 296 of NewAwkParser.jjt
                t= consumeToken(TypeString);
            }
            else {
                pushOntoCallStack("Type", "NewAwkParser.jjt", 296, 4);
                throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_296$column_4, parsingStack);
            }
            // Code for CodeBlock specified on line 297 of NewAwkParser.jjt
            Type22.type= t.getImage();
            // Code for ZeroOrMore specified on line 298 of NewAwkParser.jjt
            while (nextTokenType()== ArrayAuf) {
                // Code for RegexpRef specified on line 298 of NewAwkParser.jjt
                consumeToken(ArrayAuf);
                // Code for RegexpRef specified on line 298 of NewAwkParser.jjt
                consumeToken(ArrayZu);
                // Code for CodeBlock specified on line 299 of NewAwkParser.jjt
                Type22.isArray= true;
                Type22.arrayTypeDimension++;
            }
            if (trace_enabled) LOGGER.info("Exiting normally from Type");
        }
        catch(ParseException e) {
            parseException22= e;
            throw e;
        }
        finally {
            if (parseException22== null) {
                restoreCallStack(callStackSize22);
            }
            if (buildTree) {
                if (parseException22== null) {
                    closeNodeScope(Type22, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException22.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 301
    final public void ReturnStmnt() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 301 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean ReturnStmnt23forced= false;
        ReturnStatement ReturnStmnt23= null;
        if (buildTree) {
            ReturnStmnt23= new ReturnStatement();
            openNodeScope(ReturnStmnt23);
        }
        ParseException parseException23= null;
        int callStackSize23= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 301 of NewAwkParser.jjt
            consumeToken(RETURN);
            // Code for NonTerminal specified on line 301 of NewAwkParser.jjt
            pushOntoCallStack("ReturnStmnt", "NewAwkParser.jjt", 301, 41);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 301 of NewAwkParser.jjt
            consumeToken(SEMICOLON);
            if (trace_enabled) LOGGER.info("Exiting normally from ReturnStmnt");
        }
        catch(ParseException e) {
            parseException23= e;
            throw e;
        }
        finally {
            if (parseException23== null) {
                restoreCallStack(callStackSize23);
            }
            if (buildTree) {
                if (parseException23== null) {
                    closeNodeScope(ReturnStmnt23, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException23.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // "Klammeraffe"
    // NewAwkParser.jjt, line 303
    final public void KlammerAffe() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 303 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean KlammerAffe24forced= false;
        KlammerAffe KlammerAffe24= null;
        if (buildTree) {
            KlammerAffe24= new KlammerAffe();
            openNodeScope(KlammerAffe24);
        }
        ParseException parseException24= null;
        int callStackSize24= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 304 of NewAwkParser.jjt
            consumeToken(StringLiteral);
            // Code for RegexpRef specified on line 304 of NewAwkParser.jjt
            consumeToken(AT);
            // Code for RegexpRef specified on line 304 of NewAwkParser.jjt
            consumeToken(BlockAuf);
            // Code for OneOrMore specified on line 305 of NewAwkParser.jjt
            do {
                // Code for NonTerminal specified on line 305 of NewAwkParser.jjt
                pushOntoCallStack("KlammerAffe", "NewAwkParser.jjt", 305, 6);
                try {
                    KlammerAffeAusdruck();
                }
                finally {
                    popCallStack();
                }
            }
            while (nextTokenType()== Colon||nextTokenType== ConditionalNot);
            // Code for RegexpRef specified on line 306 of NewAwkParser.jjt
            consumeToken(BlockZu);
            if (trace_enabled) LOGGER.info("Exiting normally from KlammerAffe");
        }
        catch(ParseException e) {
            parseException24= e;
            throw e;
        }
        finally {
            if (parseException24== null) {
                restoreCallStack(callStackSize24);
            }
            if (buildTree) {
                if (parseException24== null) {
                    closeNodeScope(KlammerAffe24, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException24.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 307
    final public void KlammerAffeAusdruck() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 307 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean KlammerAffeAusdruck25forced= false;
        KlammerAffeAusdruck KlammerAffeAusdruck25= null;
        if (buildTree) {
            KlammerAffeAusdruck25= new KlammerAffeAusdruck();
            openNodeScope(KlammerAffeAusdruck25);
        }
        ParseException parseException25= null;
        int callStackSize25= parsingStack.size();
        try {
            // Code for ZeroOrOne specified on line 308 of NewAwkParser.jjt
            if (nextTokenType()== ConditionalNot) {
                // Code for RegexpRef specified on line 308 of NewAwkParser.jjt
                consumeToken(ConditionalNot);
            }
            // Code for RegexpRef specified on line 309 of NewAwkParser.jjt
            consumeToken(Colon);
            // Code for ExpansionChoice specified on line 310 of NewAwkParser.jjt
            if (nextTokenType()== INTEGER_CLASS) {
                // Code for RegexpRef specified on line 310 of NewAwkParser.jjt
                consumeToken(INTEGER_CLASS);
            }
            else if (nextTokenType()== DOUBLE_CLASS) {
                // Code for RegexpRef specified on line 310 of NewAwkParser.jjt
                consumeToken(DOUBLE_CLASS);
            }
            else if (nextTokenType()== CHAR_CLASS) {
                // Code for RegexpRef specified on line 310 of NewAwkParser.jjt
                consumeToken(CHAR_CLASS);
            }
            else if (nextTokenType()== BOOLEAN_CLASS) {
                // Code for RegexpRef specified on line 311 of NewAwkParser.jjt
                consumeToken(BOOLEAN_CLASS);
            }
            else if (nextTokenType()== TypeString) {
                // Code for RegexpRef specified on line 311 of NewAwkParser.jjt
                consumeToken(TypeString);
                // Code for ZeroOrOne specified on line 311 of NewAwkParser.jjt
                if (nextTokenType()== StringLiteral) {
                    // Code for NonTerminal specified on line 311 of NewAwkParser.jjt
                    pushOntoCallStack("KlammerAffeAusdruck", "NewAwkParser.jjt", 311, 43);
                    try {
                        KlammerAffeStringRegex();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else if (nextTokenType()== BEGIN) {
                // Code for RegexpRef specified on line 311 of NewAwkParser.jjt
                consumeToken(BEGIN);
            }
            else if (nextTokenType()== END) {
                // Code for RegexpRef specified on line 311 of NewAwkParser.jjt
                consumeToken(END);
            }
            else {
                pushOntoCallStack("KlammerAffeAusdruck", "NewAwkParser.jjt", 310, 10);
                throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_310$column_10, parsingStack);
            }
            // Code for RegexpRef specified on line 312 of NewAwkParser.jjt
            consumeToken(Colon);
            // Code for RegexpRef specified on line 313 of NewAwkParser.jjt
            consumeToken(BlockAuf);
            // Code for RegexpRef specified on line 314 of NewAwkParser.jjt
            consumeToken(RETURN);
            // Code for ZeroOrOne specified on line 315 of NewAwkParser.jjt
            if (first_set$NewAwkParser_jjt$line_315$column_10.contains(nextTokenType())) {
                // Code for ExpansionChoice specified on line 315 of NewAwkParser.jjt
                if (nextTokenType()== THIS) {
                    // Code for RegexpRef specified on line 315 of NewAwkParser.jjt
                    consumeToken(THIS);
                }
                else if (nextTokenType()== IntegerLiteral) {
                    // Code for RegexpRef specified on line 315 of NewAwkParser.jjt
                    consumeToken(IntegerLiteral);
                }
                else if (nextTokenType()== DoubleLiteral) {
                    // Code for RegexpRef specified on line 315 of NewAwkParser.jjt
                    consumeToken(DoubleLiteral);
                }
                else if (nextTokenType()== CharLiteral) {
                    // Code for RegexpRef specified on line 316 of NewAwkParser.jjt
                    consumeToken(CharLiteral);
                }
                else if (nextTokenType()== BooleanLiteral) {
                    // Code for RegexpRef specified on line 316 of NewAwkParser.jjt
                    consumeToken(BooleanLiteral);
                }
                else if (nextTokenType()== StringLiteral) {
                    // Code for RegexpRef specified on line 316 of NewAwkParser.jjt
                    consumeToken(StringLiteral);
                }
                else {
                    pushOntoCallStack("KlammerAffeAusdruck", "NewAwkParser.jjt", 315, 11);
                    throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_315$column_11, parsingStack);
                }
            }
            // Code for RegexpRef specified on line 317 of NewAwkParser.jjt
            consumeToken(SEMICOLON);
            // Code for RegexpRef specified on line 318 of NewAwkParser.jjt
            consumeToken(BlockZu);
            if (trace_enabled) LOGGER.info("Exiting normally from KlammerAffeAusdruck");
        }
        catch(ParseException e) {
            parseException25= e;
            throw e;
        }
        finally {
            if (parseException25== null) {
                restoreCallStack(callStackSize25);
            }
            if (buildTree) {
                if (parseException25== null) {
                    closeNodeScope(KlammerAffeAusdruck25, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException25.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // NewAwkParser.jjt, line 319
    final public void KlammerAffeStringRegex() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 319 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean KlammerAffeStringRegex26forced= false;
        KlammerAffeStringRegex KlammerAffeStringRegex26= null;
        if (buildTree) {
            KlammerAffeStringRegex26= new KlammerAffeStringRegex();
            openNodeScope(KlammerAffeStringRegex26);
        }
        ParseException parseException26= null;
        int callStackSize26= parsingStack.size();
        try {
            // Code for RegexpRef specified on line 319 of NewAwkParser.jjt
            consumeToken(StringLiteral);
            if (trace_enabled) LOGGER.info("Exiting normally from KlammerAffeStringRegex");
        }
        catch(ParseException e) {
            parseException26= e;
            throw e;
        }
        finally {
            if (parseException26== null) {
                restoreCallStack(callStackSize26);
            }
            if (buildTree) {
                if (parseException26== null) {
                    closeNodeScope(KlammerAffeStringRegex26, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException26.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // Print
    // NewAwkParser.jjt, line 321
    final public void PrintStmnt() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 321 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean PrintStmnt27forced= false;
        PrintStmnt PrintStmnt27= null;
        if (buildTree) {
            PrintStmnt27= new PrintStmnt();
            openNodeScope(PrintStmnt27);
        }
        ParseException parseException27= null;
        int callStackSize27= parsingStack.size();
        try {
            // Code for ExpansionChoice specified on line 321 of NewAwkParser.jjt
            if (nextTokenType()== PRINT_LINE) {
                // Code for RegexpRef specified on line 321 of NewAwkParser.jjt
                consumeToken(PRINT_LINE);
            }
            else if (nextTokenType()== PRINT) {
                // Code for RegexpRef specified on line 321 of NewAwkParser.jjt
                consumeToken(PRINT);
            }
            else {
                pushOntoCallStack("PrintStmnt", "NewAwkParser.jjt", 321, 26);
                throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_321$column_26, parsingStack);
            }
            // Code for RegexpRef specified on line 322 of NewAwkParser.jjt
            consumeToken(KlammerAuf);
            // Code for NonTerminal specified on line 322 of NewAwkParser.jjt
            pushOntoCallStack("PrintStmnt", "NewAwkParser.jjt", 322, 18);
            try {
                Expr();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified on line 322 of NewAwkParser.jjt
            consumeToken(KlammerZu);
            // Code for RegexpRef specified on line 322 of NewAwkParser.jjt
            consumeToken(SEMICOLON);
            if (trace_enabled) LOGGER.info("Exiting normally from PrintStmnt");
        }
        catch(ParseException e) {
            parseException27= e;
            throw e;
        }
        finally {
            if (parseException27== null) {
                restoreCallStack(callStackSize27);
            }
            if (buildTree) {
                if (parseException27== null) {
                    closeNodeScope(PrintStmnt27, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException27.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    // Next
    // NewAwkParser.jjt, line 324
    final public void NextStmnt() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 324 of NewAwkParser.jjt");
        if (cancelled) throw new CancellationException();
        boolean NextStmnt28forced= false;
        NextStmnt NextStmnt28= null;
        if (buildTree) {
            NextStmnt28= new NextStmnt();
            openNodeScope(NextStmnt28);
        }
        ParseException parseException28= null;
        int callStackSize28= parsingStack.size();
        Token t;
        try {
            // Code for ExpansionChoice specified on line 325 of NewAwkParser.jjt
            if (nextTokenType()== NEXT) {
                // Code for RegexpRef specified on line 325 of NewAwkParser.jjt
                t= consumeToken(NEXT);
                // Code for CodeBlock specified on line 325 of NewAwkParser.jjt
                NextStmnt28.nextValue= t.getImage();
            }
            else if (nextTokenType()== NEXT_INT) {
                // Code for RegexpRef specified on line 326 of NewAwkParser.jjt
                t= consumeToken(NEXT_INT);
                // Code for CodeBlock specified on line 326 of NewAwkParser.jjt
                NextStmnt28.nextValue= t.getImage();
            }
            else if (nextTokenType()== NEXT_DOUBLE) {
                // Code for RegexpRef specified on line 327 of NewAwkParser.jjt
                t= consumeToken(NEXT_DOUBLE);
                // Code for CodeBlock specified on line 327 of NewAwkParser.jjt
                NextStmnt28.nextValue= t.getImage();
            }
            else if (nextTokenType()== NEXT_CHAR) {
                // Code for RegexpRef specified on line 328 of NewAwkParser.jjt
                t= consumeToken(NEXT_CHAR);
                // Code for CodeBlock specified on line 328 of NewAwkParser.jjt
                NextStmnt28.nextValue= t.getImage();
            }
            else if (nextTokenType()== NEXT_BOOLEAN) {
                // Code for RegexpRef specified on line 329 of NewAwkParser.jjt
                t= consumeToken(NEXT_BOOLEAN);
                // Code for CodeBlock specified on line 329 of NewAwkParser.jjt
                NextStmnt28.nextValue= t.getImage();
            }
            else if (nextTokenType()== NEXT_STRING) {
                // Code for RegexpRef specified on line 330 of NewAwkParser.jjt
                t= consumeToken(NEXT_STRING);
                // Code for CodeBlock specified on line 330 of NewAwkParser.jjt
                NextStmnt28.nextValue= t.getImage();
            }
            else {
                pushOntoCallStack("NextStmnt", "NewAwkParser.jjt", 325, 2);
                throw new ParseException(currentToken.getNext(), first_set$NewAwkParser_jjt$line_325$column_2, parsingStack);
            }
            // Code for RegexpRef specified on line 331 of NewAwkParser.jjt
            consumeToken(KlammerAuf);
            // Code for RegexpRef specified on line 331 of NewAwkParser.jjt
            consumeToken(KlammerZu);
            if (trace_enabled) LOGGER.info("Exiting normally from NextStmnt");
        }
        catch(ParseException e) {
            parseException28= e;
            throw e;
        }
        finally {
            if (parseException28== null) {
                restoreCallStack(callStackSize28);
            }
            if (buildTree) {
                if (parseException28== null) {
                    closeNodeScope(NextStmnt28, true);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException28.getMessage());
                    clearNodeScope();
                }
            }
        }
    }

    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_207$column_6= EnumSet.of(VOID, TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString, ID);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_210$column_6= EnumSet.of(VOID, TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_218$column_6$= EnumSet.of(VOID, TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_218$column_6= EnumSet.of(TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_220$column_33= EnumSet.of(TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_223$column_6= EnumSet.of(RETURN, IF, BlockAuf, TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString, ID, PRINT_LINE, PRINT);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_244$column_34= EnumSet.of(RETURN, IF, BlockAuf, TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString, ID, PRINT_LINE, PRINT);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_251$column_33= EnumSet.of(EQUAL, NOT_EQUAL, G_OR_EQUAL, S_OR_EQUAL, GREATER, SMALLER);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_251$column_34= EnumSet.of(EQUAL, NOT_EQUAL, G_OR_EQUAL, S_OR_EQUAL, GREATER, SMALLER);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_252$column_33= EnumSet.of(PLUS, MINUS);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_253$column_34= EnumSet.of(MULTIPLICATION, DIVISION, MODULO);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_254$column_23= EnumSet.of(NullLiteral, KlammerAuf, BlockAuf, BooleanLiteral, CharLiteral, IntegerLiteral, DoubleLiteral, ID, StringLiteral, PRINT_LINE, PRINT, NEXT, NEXT_INT, NEXT_DOUBLE, NEXT_CHAR, NEXT_BOOLEAN, NEXT_STRING);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_254$column_31= EnumSet.of(PLUS, MINUS);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_256$column_6$= EnumSet.of(NullLiteral, KlammerAuf, BlockAuf, BooleanLiteral, CharLiteral, IntegerLiteral, DoubleLiteral, ID, StringLiteral, PRINT_LINE, PRINT, NEXT, NEXT_INT, NEXT_DOUBLE, NEXT_CHAR, NEXT_BOOLEAN, NEXT_STRING);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_256$column_6= EnumSet.of(NEXT, NEXT_INT, NEXT_DOUBLE, NEXT_CHAR, NEXT_BOOLEAN, NEXT_STRING);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_285$column_10= EnumSet.of(_TOKEN_71, _TOKEN_72, _TOKEN_73, _TOKEN_74, _TOKEN_75);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_285$column_11= EnumSet.of(_TOKEN_71, _TOKEN_72, _TOKEN_73, _TOKEN_74, _TOKEN_75);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_293$column_45= EnumSet.of(PLUS, MINUS, ConditionalNot, NullLiteral, KlammerAuf, BlockAuf, BooleanLiteral, CharLiteral, IntegerLiteral, DoubleLiteral, ID, StringLiteral, PRINT_LINE, PRINT, NEXT, NEXT_INT, NEXT_DOUBLE, NEXT_CHAR, NEXT_BOOLEAN, NEXT_STRING);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_296$column_4= EnumSet.of(TypeInt, TypeDouble, TypeChar, TypeBoolean, TypeString);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_310$column_10= EnumSet.of(INTEGER_CLASS, DOUBLE_CLASS, CHAR_CLASS, BOOLEAN_CLASS, BEGIN, END, TypeString);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_315$column_10= EnumSet.of(THIS, BooleanLiteral, CharLiteral, IntegerLiteral, DoubleLiteral, StringLiteral);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_315$column_11= EnumSet.of(THIS, BooleanLiteral, CharLiteral, IntegerLiteral, DoubleLiteral, StringLiteral);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_321$column_26= EnumSet.of(PRINT_LINE, PRINT);
    static private final EnumSet<TokenType> first_set$NewAwkParser_jjt$line_325$column_2= EnumSet.of(NEXT, NEXT_INT, NEXT_DOUBLE, NEXT_CHAR, NEXT_BOOLEAN, NEXT_STRING);
    private final boolean scanToken(TokenType expectedType) {
        if (remainingLookahead<=0) return true;
        if (currentLookaheadToken.getNext()== null) {
            Token nextToken= token_source.getNextToken();
            currentLookaheadToken.setNext(nextToken);
        }
        currentLookaheadToken= currentLookaheadToken.getNext();
        TokenType type= currentLookaheadToken.getType();
        if (type!=expectedType) return false;
        if (remainingLookahead!=Integer.MAX_VALUE) remainingLookahead--;
        //     if (type == upToTokenType) remainingLookahead = 0;
        return true;
    }

    private final boolean scanToken(EnumSet<TokenType> types) {
        if (remainingLookahead<=0) return true;
        if (currentLookaheadToken.getNext()== null) {
            Token nextToken= token_source.getNextToken();
            currentLookaheadToken.setNext(nextToken);
        }
        currentLookaheadToken= currentLookaheadToken.getNext();
        TokenType type= currentLookaheadToken.getType();
        if (!types.contains(type)) return false;
        if (remainingLookahead!=Integer.MAX_VALUE) remainingLookahead--;
        //     if (type == upToTokenType) remainingLookahead = 0;
        return true;
    }

    //====================================
    // Lookahead Routines
    //====================================
    private final boolean check$NewAwkParser_jjt$line_207$column_6$() {
        if (remainingLookahead<=0) return true;
        Token token29= currentLookaheadToken;
        int remainingLookahead29= remainingLookahead;
        if (!check$NewAwkParser_jjt$line_207$column_6()) {
            currentLookaheadToken= token29;
            remainingLookahead= remainingLookahead29;
            if (!check$NewAwkParser_jjt$line_208$column_6()) {
                currentLookaheadToken= token29;
                remainingLookahead= remainingLookahead29;
                if (!check$NewAwkParser_jjt$line_209$column_6()) {
                    currentLookaheadToken= token29;
                    remainingLookahead= remainingLookahead29;
                    if (!check$NewAwkParser_jjt$line_210$column_6()) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_207$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("CompilationUnit", "NewAwkParser.jjt", 207, 20);
        stopAtScanLimit= false;
        if (!check$VariableDecl()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_208$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("CompilationUnit", "NewAwkParser.jjt", 208, 19);
        stopAtScanLimit= false;
        if (!check$Assignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_209$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("CompilationUnit", "NewAwkParser.jjt", 209, 19);
        stopAtScanLimit= false;
        if (!check$VariableDeclAndAssignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_210$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("CompilationUnit", "NewAwkParser.jjt", 210, 6);
        if (!check$MethodDecl()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_218$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("MethodDecl", "NewAwkParser.jjt", 218, 6);
        if (!check$Type()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_220$column_33() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("ParameterList", "NewAwkParser.jjt", 220, 33);
        if (!check$Type()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(ID)) return false;
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_220$column_45() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(COMMA)) return false;
        pushOntoLookaheadStack("ParameterList", "NewAwkParser.jjt", 220, 53);
        stopAtScanLimit= false;
        if (!check$Type()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(ID)) return false;
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_223$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 223, 6);
        if (!check$Block()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_223$column_14() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 223, 14);
        if (!check$IfStmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_223$column_24() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 223, 24);
        if (!check$ReturnStmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_223$column_38() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 223, 38);
        if (!check$PrintStmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_224$column_8() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 224, 18);
        if (!check$VariableDecl()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_225$column_8() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 225, 18);
        if (!check$Assignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_226$column_8() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 226, 18);
        if (!check$VariableDeclAndAssignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_244$column_34() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Block", "NewAwkParser.jjt", 244, 34);
        if (!check$Stmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_245$column_66() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(ELSE)) return false;
        pushOntoLookaheadStack("IfStmnt", "NewAwkParser.jjt", 245, 73);
        stopAtScanLimit= false;
        if (!check$Stmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_247$column_37() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(Zuweisung)) return false;
        pushOntoLookaheadStack("Expr", "NewAwkParser.jjt", 247, 49);
        stopAtScanLimit= false;
        if (!check$LogicalOrExpr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_248$column_49() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(ConditionalOr)) return false;
        pushOntoLookaheadStack("LogicalOrExpr", "NewAwkParser.jjt", 248, 65);
        stopAtScanLimit= false;
        if (!check$LogicalAndExpr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_249$column_50() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(ConditionalAnd)) return false;
        pushOntoLookaheadStack("LogicalAndExpr", "NewAwkParser.jjt", 249, 67);
        stopAtScanLimit= false;
        if (!check$LogicalNotExpr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_251$column_33() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(first_set$NewAwkParser_jjt$line_251$column_34)) return false;
        pushOntoLookaheadStack("CompExpr", "NewAwkParser.jjt", 251, 111);
        stopAtScanLimit= false;
        if (!check$Sum()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_252$column_32() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(first_set$NewAwkParser_jjt$line_252$column_33)) return false;
        pushOntoLookaheadStack("Sum", "NewAwkParser.jjt", 252, 52);
        stopAtScanLimit= false;
        if (!check$Product()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_253$column_33() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(first_set$NewAwkParser_jjt$line_253$column_34)) return false;
        pushOntoLookaheadStack("Product", "NewAwkParser.jjt", 253, 76);
        stopAtScanLimit= false;
        if (!check$Sign()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_254$column_23() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Sign", "NewAwkParser.jjt", 254, 23);
        if (!check$Atom()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_254$column_30() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(first_set$NewAwkParser_jjt$line_254$column_31)) return false;
        pushOntoLookaheadStack("Sign", "NewAwkParser.jjt", 254, 50);
        stopAtScanLimit= false;
        if (!check$Atom()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_256$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 256, 6);
        if (!check$NextStmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_256$column_18() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 256, 18);
        if (!check$PrintStmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_256$column_31() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 256, 41);
        if (!check$KlammerAffe()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_257$column_7() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(ID)) return false;
        while (remainingLookahead> 0) {
            Token token30= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_258$column_10()) {
                currentLookaheadToken= token30;
                break;
            }
        }
        Token token31= currentLookaheadToken;
        if (!scanToken(_TOKEN_71)) currentLookaheadToken= token31;
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_258$column_10() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 258, 10);
        if (!check$ArrayAccess()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_263$column_7() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(BlockAuf)) return false;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 263, 18);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token32= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_264$column_10()) {
                currentLookaheadToken= token32;
                break;
            }
        }
        if (!scanToken(BlockZu)) return false;
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_264$column_10() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(COMMA)) return false;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 264, 18);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_269$column_7() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(KlammerAuf)) return false;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 269, 20);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(KlammerZu)) return false;
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_284$column_7() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(StringLiteral)) return false;
        Token token33= currentLookaheadToken;
        if (!scanToken(first_set$NewAwkParser_jjt$line_285$column_10)) currentLookaheadToken= token33;
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_293$column_45() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("MethodCall", "NewAwkParser.jjt", 293, 45);
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token34= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_293$column_51()) {
                currentLookaheadToken= token34;
                break;
            }
        }
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_293$column_51() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(COMMA)) return false;
        pushOntoLookaheadStack("MethodCall", "NewAwkParser.jjt", 293, 59);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_298$column_4() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(ArrayAuf)) return false;
        if (!scanToken(ArrayZu)) return false;
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_305$column_6() {
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("KlammerAffe", "NewAwkParser.jjt", 305, 6);
        if (!check$KlammerAffeAusdruck()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$NewAwkParser_jjt$line_311$column_29() {
        if (remainingLookahead<=0) return true;
        if (!scanToken(TypeString)) return false;
        Token token35= currentLookaheadToken;
        if (!scanToken(StringLiteral)) currentLookaheadToken= token35;
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_207$column_6() {
        currentLookaheadToken= currentToken;
        remainingLookahead= 14;
        stopAtScanLimit= false;
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("CompilationUnit", "NewAwkParser.jjt", 207, 20);
        stopAtScanLimit= false;
        if (!check$VariableDecl()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_208$column_6() {
        currentLookaheadToken= currentToken;
        remainingLookahead= 4;
        stopAtScanLimit= false;
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("CompilationUnit", "NewAwkParser.jjt", 208, 19);
        stopAtScanLimit= false;
        if (!check$Assignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_209$column_6() {
        currentLookaheadToken= currentToken;
        remainingLookahead= 8;
        stopAtScanLimit= false;
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("CompilationUnit", "NewAwkParser.jjt", 209, 19);
        stopAtScanLimit= false;
        if (!check$VariableDeclAndAssignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_224$column_8() {
        currentLookaheadToken= currentToken;
        remainingLookahead= UNLIMITED;
        stopAtScanLimit= true;
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 224, 18);
        if (!check$VariableDecl()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_225$column_8() {
        currentLookaheadToken= currentToken;
        remainingLookahead= UNLIMITED;
        stopAtScanLimit= true;
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 225, 18);
        if (!check$Assignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_226$column_8() {
        currentLookaheadToken= currentToken;
        remainingLookahead= UNLIMITED;
        stopAtScanLimit= true;
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Stmnt", "NewAwkParser.jjt", 226, 18);
        if (!check$VariableDeclAndAssignement()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_256$column_31() {
        currentLookaheadToken= currentToken;
        remainingLookahead= UNLIMITED;
        stopAtScanLimit= true;
        if (remainingLookahead<=0) return true;
        pushOntoLookaheadStack("Atom", "NewAwkParser.jjt", 256, 41);
        if (!check$KlammerAffe()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean scan$NewAwkParser_jjt$line_284$column_7() {
        currentLookaheadToken= currentToken;
        remainingLookahead= 3;
        stopAtScanLimit= false;
        if (remainingLookahead<=0) return true;
        if (!scanToken(StringLiteral)) return false;
        Token token36= currentLookaheadToken;
        if (!scanToken(first_set$NewAwkParser_jjt$line_285$column_10)) currentLookaheadToken= token36;
        return true;
    }

    private final boolean check$CompilationUnit() {
        if (!check$NewAwkParser_jjt$line_207$column_6$()) {
            return false;
        }
        while (remainingLookahead> 0) {
            Token token37= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_207$column_6$()) {
                currentLookaheadToken= token37;
                break;
            }
        }
        if (!scanToken(EOF)) return false;
        return true;
    }

    private final boolean check$VariableDecl() {
        pushOntoLookaheadStack("VariableDecl", "NewAwkParser.jjt", 213, 30);
        if (!check$Type()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(ID)) return false;
        if (!scanToken(SEMICOLON)) return false;
        return true;
    }

    private final boolean check$Assignement() {
        if (!scanToken(ID)) return false;
        if (!scanToken(Zuweisung)) return false;
        pushOntoLookaheadStack("Assignement", "NewAwkParser.jjt", 214, 44);
        stopAtScanLimit= false;
        if (!check$ExprStmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$VariableDeclAndAssignement() {
        pushOntoLookaheadStack("VariableDeclAndAssignement", "NewAwkParser.jjt", 216, 5);
        if (!check$Type()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(ID)) return false;
        if (!scanToken(Zuweisung)) return false;
        pushOntoLookaheadStack("VariableDeclAndAssignement", "NewAwkParser.jjt", 216, 27);
        stopAtScanLimit= false;
        if (!check$ExprStmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$MethodDecl() {
        Token token38= currentLookaheadToken;
        int remainingLookahead38= remainingLookahead;
        if (!check$NewAwkParser_jjt$line_218$column_6()) {
            currentLookaheadToken= token38;
            remainingLookahead= remainingLookahead38;
            if (!scanToken(VOID)) {
                return false;
            }
        }
        if (!scanToken(ID)) return false;
        if (!scanToken(KlammerAuf)) return false;
        pushOntoLookaheadStack("MethodDecl", "NewAwkParser.jjt", 219, 23);
        stopAtScanLimit= false;
        if (!check$ParameterList()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(KlammerZu)) return false;
        pushOntoLookaheadStack("MethodDecl", "NewAwkParser.jjt", 219, 49);
        stopAtScanLimit= false;
        if (!check$Block()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$ParameterList() {
        Token token39= currentLookaheadToken;
        if (!check$NewAwkParser_jjt$line_220$column_33()) currentLookaheadToken= token39;
        while (remainingLookahead> 0) {
            Token token40= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_220$column_45()) {
                currentLookaheadToken= token40;
                break;
            }
        }
        return true;
    }

    private final boolean check$Stmnt() {
        Token token41= currentLookaheadToken;
        int remainingLookahead41= remainingLookahead;
        if (!check$NewAwkParser_jjt$line_223$column_6()) {
            currentLookaheadToken= token41;
            remainingLookahead= remainingLookahead41;
            if (!check$NewAwkParser_jjt$line_223$column_14()) {
                currentLookaheadToken= token41;
                remainingLookahead= remainingLookahead41;
                if (!check$NewAwkParser_jjt$line_223$column_24()) {
                    currentLookaheadToken= token41;
                    remainingLookahead= remainingLookahead41;
                    if (!check$NewAwkParser_jjt$line_223$column_38()) {
                        currentLookaheadToken= token41;
                        remainingLookahead= remainingLookahead41;
                        if (!check$NewAwkParser_jjt$line_224$column_8()) {
                            currentLookaheadToken= token41;
                            remainingLookahead= remainingLookahead41;
                            if (!check$NewAwkParser_jjt$line_225$column_8()) {
                                currentLookaheadToken= token41;
                                remainingLookahead= remainingLookahead41;
                                if (!check$NewAwkParser_jjt$line_226$column_8()) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    private final boolean check$Block() {
        if (!scanToken(BlockAuf)) return false;
        if (!check$NewAwkParser_jjt$line_244$column_34()) {
            return false;
        }
        while (remainingLookahead> 0) {
            Token token42= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_244$column_34()) {
                currentLookaheadToken= token42;
                break;
            }
        }
        if (!scanToken(BlockZu)) return false;
        return true;
    }

    private final boolean check$IfStmnt() {
        if (!scanToken(IF)) return false;
        if (!scanToken(KlammerAuf)) return false;
        pushOntoLookaheadStack("IfStmnt", "NewAwkParser.jjt", 245, 42);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(KlammerZu)) return false;
        pushOntoLookaheadStack("IfStmnt", "NewAwkParser.jjt", 245, 59);
        stopAtScanLimit= false;
        if (!check$Stmnt()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token43= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_245$column_66()) {
                currentLookaheadToken= token43;
                break;
            }
        }
        if (!scanToken(SEMICOLON)) return false;
        return true;
    }

    private final boolean check$ExprStmnt() {
        pushOntoLookaheadStack("ExprStmnt", "NewAwkParser.jjt", 246, 25);
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(SEMICOLON)) return false;
        return true;
    }

    private final boolean check$Expr() {
        pushOntoLookaheadStack("Expr", "NewAwkParser.jjt", 247, 21);
        if (!check$LogicalOrExpr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token44= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_247$column_37()) {
                currentLookaheadToken= token44;
                break;
            }
        }
        return true;
    }

    private final boolean check$LogicalOrExpr() {
        pushOntoLookaheadStack("LogicalOrExpr", "NewAwkParser.jjt", 248, 33);
        if (!check$LogicalAndExpr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token45= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_248$column_49()) {
                currentLookaheadToken= token45;
                break;
            }
        }
        return true;
    }

    private final boolean check$LogicalAndExpr() {
        pushOntoLookaheadStack("LogicalAndExpr", "NewAwkParser.jjt", 249, 34);
        if (!check$LogicalNotExpr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token46= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_249$column_50()) {
                currentLookaheadToken= token46;
                break;
            }
        }
        return true;
    }

    private final boolean check$LogicalNotExpr() {
        while (remainingLookahead> 0) {
            Token token47= currentLookaheadToken;
            if (!scanToken(ConditionalNot)) {
                currentLookaheadToken= token47;
                break;
            }
        }
        pushOntoLookaheadStack("LogicalNotExpr", "NewAwkParser.jjt", 250, 54);
        stopAtScanLimit= false;
        if (!check$CompExpr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        return true;
    }

    private final boolean check$CompExpr() {
        pushOntoLookaheadStack("CompExpr", "NewAwkParser.jjt", 251, 28);
        if (!check$Sum()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token48= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_251$column_33()) {
                currentLookaheadToken= token48;
                break;
            }
        }
        return true;
    }

    private final boolean check$Sum() {
        pushOntoLookaheadStack("Sum", "NewAwkParser.jjt", 252, 23);
        if (!check$Product()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token49= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_252$column_32()) {
                currentLookaheadToken= token49;
                break;
            }
        }
        return true;
    }

    private final boolean check$Product() {
        pushOntoLookaheadStack("Product", "NewAwkParser.jjt", 253, 27);
        if (!check$Sign()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        while (remainingLookahead> 0) {
            Token token50= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_253$column_33()) {
                currentLookaheadToken= token50;
                break;
            }
        }
        return true;
    }

    private final boolean check$Sign() {
        Token token51= currentLookaheadToken;
        int remainingLookahead51= remainingLookahead;
        if (!check$NewAwkParser_jjt$line_254$column_23()) {
            currentLookaheadToken= token51;
            remainingLookahead= remainingLookahead51;
            if (!check$NewAwkParser_jjt$line_254$column_30()) {
                return false;
            }
        }
        return true;
    }

    private final boolean check$Atom() {
        Token token52= currentLookaheadToken;
        int remainingLookahead52= remainingLookahead;
        if (!check$NewAwkParser_jjt$line_256$column_6()) {
            currentLookaheadToken= token52;
            remainingLookahead= remainingLookahead52;
            if (!check$NewAwkParser_jjt$line_256$column_18()) {
                currentLookaheadToken= token52;
                remainingLookahead= remainingLookahead52;
                if (!check$NewAwkParser_jjt$line_256$column_31()) {
                    currentLookaheadToken= token52;
                    remainingLookahead= remainingLookahead52;
                    if (!check$NewAwkParser_jjt$line_257$column_7()) {
                        currentLookaheadToken= token52;
                        remainingLookahead= remainingLookahead52;
                        if (!check$NewAwkParser_jjt$line_263$column_7()) {
                            currentLookaheadToken= token52;
                            remainingLookahead= remainingLookahead52;
                            if (!check$NewAwkParser_jjt$line_269$column_7()) {
                                currentLookaheadToken= token52;
                                remainingLookahead= remainingLookahead52;
                                if (!scanToken(BooleanLiteral)) {
                                    currentLookaheadToken= token52;
                                    remainingLookahead= remainingLookahead52;
                                    if (!scanToken(IntegerLiteral)) {
                                        currentLookaheadToken= token52;
                                        remainingLookahead= remainingLookahead52;
                                        if (!scanToken(DoubleLiteral)) {
                                            currentLookaheadToken= token52;
                                            remainingLookahead= remainingLookahead52;
                                            if (!scanToken(CharLiteral)) {
                                                currentLookaheadToken= token52;
                                                remainingLookahead= remainingLookahead52;
                                                if (!scanToken(NullLiteral)) {
                                                    currentLookaheadToken= token52;
                                                    remainingLookahead= remainingLookahead52;
                                                    if (!check$NewAwkParser_jjt$line_284$column_7()) {
                                                        return false;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    private final boolean check$MethodCall() {
        if (!scanToken(ID)) return false;
        if (!scanToken(KlammerAuf)) return false;
        Token token53= currentLookaheadToken;
        if (!check$NewAwkParser_jjt$line_293$column_45()) currentLookaheadToken= token53;
        if (!scanToken(KlammerZu)) return false;
        return true;
    }

    private final boolean check$ArrayAccess() {
        if (!scanToken(ArrayAuf)) return false;
        pushOntoLookaheadStack("ArrayAccess", "NewAwkParser.jjt", 294, 39);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(ArrayZu)) return false;
        return true;
    }

    private final boolean check$Type() {
        if (!scanToken(first_set$NewAwkParser_jjt$line_296$column_4)) return false;
        while (remainingLookahead> 0) {
            Token token54= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_298$column_4()) {
                currentLookaheadToken= token54;
                break;
            }
        }
        return true;
    }

    private final boolean check$ReturnStmnt() {
        if (!scanToken(RETURN)) return false;
        pushOntoLookaheadStack("ReturnStmnt", "NewAwkParser.jjt", 301, 41);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(SEMICOLON)) return false;
        return true;
    }

    private final boolean check$KlammerAffe() {
        if (!scanToken(StringLiteral)) return false;
        if (!scanToken(AT)) return false;
        if (!scanToken(BlockAuf)) return false;
        if (!check$NewAwkParser_jjt$line_305$column_6()) {
            return false;
        }
        while (remainingLookahead> 0) {
            Token token55= currentLookaheadToken;
            if (!check$NewAwkParser_jjt$line_305$column_6()) {
                currentLookaheadToken= token55;
                break;
            }
        }
        if (!scanToken(BlockZu)) return false;
        return true;
    }

    private final boolean check$KlammerAffeAusdruck() {
        Token token56= currentLookaheadToken;
        if (!scanToken(ConditionalNot)) currentLookaheadToken= token56;
        if (!scanToken(Colon)) return false;
        Token token57= currentLookaheadToken;
        int remainingLookahead57= remainingLookahead;
        if (!scanToken(INTEGER_CLASS)) {
            currentLookaheadToken= token57;
            remainingLookahead= remainingLookahead57;
            if (!scanToken(DOUBLE_CLASS)) {
                currentLookaheadToken= token57;
                remainingLookahead= remainingLookahead57;
                if (!scanToken(CHAR_CLASS)) {
                    currentLookaheadToken= token57;
                    remainingLookahead= remainingLookahead57;
                    if (!scanToken(BOOLEAN_CLASS)) {
                        currentLookaheadToken= token57;
                        remainingLookahead= remainingLookahead57;
                        if (!check$NewAwkParser_jjt$line_311$column_29()) {
                            currentLookaheadToken= token57;
                            remainingLookahead= remainingLookahead57;
                            if (!scanToken(BEGIN)) {
                                currentLookaheadToken= token57;
                                remainingLookahead= remainingLookahead57;
                                if (!scanToken(END)) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!scanToken(Colon)) return false;
        if (!scanToken(BlockAuf)) return false;
        if (!scanToken(RETURN)) return false;
        Token token58= currentLookaheadToken;
        if (!scanToken(first_set$NewAwkParser_jjt$line_315$column_10)) currentLookaheadToken= token58;
        if (!scanToken(SEMICOLON)) return false;
        if (!scanToken(BlockZu)) return false;
        return true;
    }

    private final boolean check$KlammerAffeStringRegex() {
        if (!scanToken(StringLiteral)) return false;
        return true;
    }

    private final boolean check$PrintStmnt() {
        if (!scanToken(first_set$NewAwkParser_jjt$line_321$column_26)) return false;
        if (!scanToken(KlammerAuf)) return false;
        pushOntoLookaheadStack("PrintStmnt", "NewAwkParser.jjt", 322, 18);
        stopAtScanLimit= false;
        if (!check$Expr()) {
            popLookaheadStack();
            return false;
        }
        popLookaheadStack();
        if (!scanToken(KlammerZu)) return false;
        if (!scanToken(SEMICOLON)) return false;
        return true;
    }

    private final boolean check$NextStmnt() {
        if (!scanToken(first_set$NewAwkParser_jjt$line_325$column_2)) return false;
        if (!scanToken(KlammerAuf)) return false;
        if (!scanToken(KlammerZu)) return false;
        return true;
    }

    private boolean trace_enabled= false;
    public void setTracingEnabled(boolean tracingEnabled) {
        trace_enabled= tracingEnabled;
    }

    /**
 * @deprecated Use #setTracingEnabled
 */
    @Deprecated public void enable_tracing() {
        setTracingEnabled(true);
    }

    /**
 * @deprecated Use #setTracingEnabled
 */
    @Deprecated public void disable_tracing() {
        setTracingEnabled(false);
    }

    ArrayList<NonTerminalCall> parsingStack= new ArrayList<> ();
    private ArrayList<NonTerminalCall> lookaheadStack= new ArrayList<> ();
    /**
 * Inner class that represents entering a grammar production
 */
    class NonTerminalCall {
        final String sourceFile;
        final String productionName;
        final int line, column;
        // We actually only use this when we're working with the LookaheadStack
        final boolean stopAtScanLimit;
        NonTerminalCall(String sourceFile, String productionName, int line, int column) {
            this.sourceFile= sourceFile;
            this.productionName= productionName;
            this.line= line;
            this.column= column;
            this.stopAtScanLimit= NewAwkParser.this.stopAtScanLimit;
        }

        //    NonTerminalCall(String sourceFile, String productionName, int line, int column) {
        //        this (sourceFile, productionName, line, column, false);
        //    }
        StackTraceElement createStackTraceElement() {
            return new StackTraceElement("NewAwkParser", productionName, sourceFile, line);
        }

        void dump(PrintStream ps) {
            ps.print(productionName);
            ps.println(" stopAtScanLimit: "+this.stopAtScanLimit);
        }

    }
    private final void pushOntoCallStack(String methodName, String fileName, int line, int column) {
        parsingStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popCallStack() {
        parsingStack.remove(parsingStack.size()-1);
    }

    private final void restoreCallStack(int prevSize) {
        while (parsingStack.size()> prevSize) {
            popCallStack();
        }
    }

    private Iterator<NonTerminalCall> stackIteratorForward() {
        final Iterator<NonTerminalCall> parseStackIterator= parsingStack.iterator();
        final Iterator<NonTerminalCall> lookaheadStackIterator= lookaheadStack.iterator();
        return new Iterator<NonTerminalCall> () {
            public boolean hasNext() {
                return parseStackIterator.hasNext()||lookaheadStackIterator.hasNext();
            }

            public NonTerminalCall next() {
                return parseStackIterator.hasNext()?parseStackIterator.next():
                lookaheadStackIterator.next();
            }

        }
        ;
    }

    private Iterator<NonTerminalCall> stackIteratorBackward() {
        final ListIterator<NonTerminalCall> parseStackIterator= parsingStack.listIterator(parsingStack.size());
        final ListIterator<NonTerminalCall> lookaheadStackIterator= lookaheadStack.listIterator(lookaheadStack.size());
        return new Iterator<NonTerminalCall> () {
            public boolean hasNext() {
                return parseStackIterator.hasPrevious()||lookaheadStackIterator.hasPrevious();
            }

            public NonTerminalCall next() {
                return lookaheadStackIterator.hasPrevious()?lookaheadStackIterator.previous():
                parseStackIterator.previous();
            }

        }
        ;
    }

    private final void pushOntoLookaheadStack(String methodName, String fileName, int line, int column) {
        lookaheadStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popLookaheadStack() {
        NonTerminalCall ntc= lookaheadStack.remove(lookaheadStack.size()-1);
        this.stopAtScanLimit= ntc.stopAtScanLimit;
    }

    private void dumpLookaheadStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= lookaheadStack.listIterator(lookaheadStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    private final boolean tolerantParsing= false;
    public boolean isParserTolerant() {
        return tolerantParsing;
    }

    public void setParserTolerant(boolean tolerantParsing) {
        if (tolerantParsing) {
            throw new UnsupportedOperationException("This parser was not built with that feature!");
        }
    }

    private Token consumeToken(TokenType expectedType) throws ParseException {
        boolean forced= false;
        InvalidToken invalidToken= null;
        Token oldToken= currentToken;
        currentToken= currentToken.getNext();
        if (currentToken== null) {
            currentToken= token_source.getNextToken();
        }
        if (currentToken.getType()!=expectedType) {
            handleUnexpectedTokenType(expectedType, forced, oldToken);
        }
        else {
            this.lastParsedToken= currentToken;
        }
        if (buildTree&&tokensAreNodes) {
            if (invalidToken!=null) {
                pushNode(invalidToken);
            }
            pushNode(currentToken);
        }
        if (trace_enabled) LOGGER.info("Consumed token of type "+currentToken.getType()+" from "+currentToken.getLocation());
        return currentToken;
    }

    private void handleUnexpectedTokenType(TokenType expectedType, boolean forced, Token oldToken) throws ParseException {
        throw new ParseException(currentToken, EnumSet.of(expectedType), parsingStack);
    }

    private class ParseState {
        Token lastParsed;
        NodeScope nodeScope;
        ParseState() {
            this.lastParsed= NewAwkParser.this.lastParsedToken;
            this.nodeScope= (NodeScope) currentNodeScope.clone();
        }

    }
    private ArrayList<ParseState> parseStateStack= new ArrayList<> ();
    void stashParseState() {
        parseStateStack.add(new ParseState());
    }

    ParseState popParseState() {
        return parseStateStack.remove(parseStateStack.size()-1);
    }

    void restoreStashedParseState() {
        ParseState state= popParseState();
        currentNodeScope= state.nodeScope;
        if (state.lastParsed!=null) {
            //REVISIT
            currentToken= lastParsedToken= state.lastParsed;
        }
    }

    private boolean buildTree= true;
    private boolean tokensAreNodes= true;
    private boolean unparsedTokensAreNodes= false;
    public void setUnparsedTokensAreNodes(boolean unparsedTokensAreNodes) {
        this.unparsedTokensAreNodes= unparsedTokensAreNodes;
    }

    public void setTokensAreNodes(boolean tokensAreNodes) {
        this.tokensAreNodes= tokensAreNodes;
    }

    NodeScope currentNodeScope= new NodeScope();
    /** 
	 * Returns the root node of the AST.  It only makes sense to call
	 * this after a successful parse. 
	 */
    public Node rootNode() {
        Node root= currentNodeScope.rootNode();
        recursivelySetInputSource(root, this.token_source.input_stream);
        return root;
    }

    static private void recursivelySetInputSource(Node n, FileLineMap fileLineMap) {
        n.setInputSource(fileLineMap);
        for (Node child : n.children()) {
            //            if (child instanceof Token) {
            //                 ((Token) child).setImage(null);
            //            } 
            recursivelySetInputSource(child, fileLineMap);
        }
    }

    /**
     * push a node onto the top of the node stack
     */
    public void pushNode(Node n) {
        currentNodeScope.add(n);
    }

    /** 
     * Returns the node on the top of the stack, and remove it from the
     * stack.  
     */
    public Node popNode() {
        return currentNodeScope.pop();
    }

    /** 
     * Returns the node currently on the top of the stack. 
     */
    public Node peekNode() {
        return currentNodeScope.peek();
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     */
    public void pokeNode(Node n) {
        currentNodeScope.poke(n);
    }

    /** Returns the number of children on the stack in the current node
	 * scope. 
	 */
    public int nodeArity() {
        return currentNodeScope.size();
    }

    public void clearNodeScope() {
        currentNodeScope.clear();
    }

    public void openNodeScope(Node n) {
        Token start= getToken(1);
        n.setBeginLine(start.getBeginLine());
        n.setBeginColumn(start.getBeginColumn());
        n.setInputSource(token_source.input_stream);
        new NodeScope();
        n.open();
        if (trace_enabled) LOGGER.info("Opened node scope for node of type: "+n.getClass().getName());
        if (trace_enabled) LOGGER.info("Scope nesting level is "+currentNodeScope.nestingLevel());
    }

    /* A definite node is constructed from a specified number of
	 * children.  That number of nodes are popped from the stack and
	 * made the children of the definite node.  Then the definite node
	 * is pushed on to the stack.
	 */
    public void closeNodeScope(Node n, int num) {
        n.setEndLine(currentToken.getEndLine());
        n.setEndColumn(currentToken.getEndColumn());
        if (trace_enabled) LOGGER.info("Closing node scope for node of type: "+n.getClass().getName()+", popping "+num+" nodes off the stack.");
        currentNodeScope.close();
        ArrayList<Node> nodes= new ArrayList<Node> ();
        for (int i= 0; i<num; i++) {
            nodes.add(popNode());
        }
        Collections.reverse(nodes);
        for (Node child : nodes) {
            if (unparsedTokensAreNodes&&(child instanceof Token)) {
                Token token= (Token) child;
                Token specialToken= token;
                while (specialToken!=null) {
                    specialToken= specialToken.getSpecialToken();
                }
                while (specialToken!=null&&specialToken!=token) {
                    n.addChild(specialToken);
                    specialToken= specialToken.getNext();
                }
            }
            n.addChild(child);
        }
        n.close();
        pushNode(n);
    }

    /**
	 * A conditional node is constructed if the condition is true.  All
	 * the nodes that have been pushed since the node was opened are
	 * made children of the conditional node, which is then pushed
	 * on to the stack.  If the condition is false the node is not
	 * constructed and they are left on the stack. 
	 */
    public void closeNodeScope(Node n, boolean condition) {
        n.setEndLine(currentToken.getEndLine());
        n.setEndColumn(currentToken.getEndColumn());
        if (condition) {
            if (trace_enabled) LOGGER.finer("Closing node scope for node of type: "+n.getClass().getName()+", popping "+nodeArity()+" nodes off the stack.");
            int a= nodeArity();
            currentNodeScope.close();
            ArrayList<Node> nodes= new ArrayList<Node> ();
            while (a--> 0) {
                nodes.add(popNode());
            }
            Collections.reverse(nodes);
            for (Node child : nodes) {
                if (unparsedTokensAreNodes&&(child instanceof Token)) {
                    Token token= (Token) child;
                    Token specialToken= token;
                    while (specialToken.getSpecialToken()!=null) {
                        specialToken= specialToken.getSpecialToken();
                    }
                    while (specialToken!=null&&specialToken!=token) {
                        n.addChild(specialToken);
                        specialToken= specialToken.getNext();
                    }
                }
                n.addChild(child);
            }
            n.close();
            if (trace_enabled) {
                LOGGER.info("Closing node scope for node of type: "+n.getClass().getName()+", leaving "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
            pushNode(n);
            if (trace_enabled) {
                LOGGER.info("Closed node scope for node of type: "+n.getClass().getName()+", there are now "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
        }
        else {
            currentNodeScope.close();
            if (trace_enabled) {
                LOGGER.info("Closed node scope for node of type: "+n.getClass().getName()+", leaving "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree= buildTree;
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    NewAwkParser jjtree= this;
    @SuppressWarnings("serial")
    class NodeScope extends ArrayList<Node>  {
        NodeScope parentScope;
        NodeScope() {
            this.parentScope= NewAwkParser.this.currentNodeScope;
            NewAwkParser.this.currentNodeScope= this;
        }

        boolean isRootScope() {
            return parentScope== null;
        }

        Node rootNode() {
            NodeScope ns= this;
            while (ns.parentScope!=null) {
                ns= ns.parentScope;
            }
            return ns.isEmpty()?null:
            ns.get(0);
        }

        Node peek() {
            return isEmpty()?parentScope.peek():
            get(size()-1);
        }

        Node pop() {
            return isEmpty()?parentScope.pop():
            remove(size()-1);
        }

        void poke(Node n) {
            if (isEmpty()) {
                parentScope.poke(n);
            }
            else {
                set(size()-1, n);
            }
        }

        void close() {
            parentScope.addAll(this);
            NewAwkParser.this.currentNodeScope= parentScope;
        }

        int nestingLevel() {
            int result= 0;
            NodeScope parent= this;
            while (parent.parentScope!=null) {
                result++;
                parent= parent.parentScope;
            }
            return result;
        }

    }
}
