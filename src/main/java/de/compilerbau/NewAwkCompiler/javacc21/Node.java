/* Generated by: JavaCC 21 Parser Generator. Node.java */
package de.compilerbau.NewAwkCompiler.javacc21;

import java.lang.reflect.Method;
import java.util.*;
import java.lang.reflect.*;
public interface Node extends Comparable<Node>  {
    /** Life-cycle hook method called after the node has been made the current
	 *  node 
	 */
    void open();
    /** 
  	 * Life-cycle hook method called after all the child nodes have been
     * added. 
     */
    void close();
    /**
     * Returns whether this node has any children.
     * 
     * @return Returns <code>true</code> if this node has any children,
     *         <code>false</code> otherwise.
     */
    default boolean hasChildNodes() {
        return getChildCount()> 0;
    }

    void setParent(Node n);
    Node getParent();
    // The following 9 methods will typically just 
    // delegate straightforwardly to a List object that
    // holds the child nodes
    void addChild(Node n);
    void addChild(int i, Node n);
    Node getChild(int i);
    void setChild(int i, Node n);
    Node removeChild(int i);
    boolean removeChild(Node n);
    default int indexOf(Node child) {
        for (int i= 0; i<getChildCount(); i++) {
            if (child== getChild(i)) {
                return i;
            }
        }
        return-1;
    }

    /**
      * Used to order Nodes by location.
      */
    default int compareTo(Node n) {
        if (this== n) return 0;
        int diff= this.getBeginLine()-n.getBeginLine();
        if (diff!=0) return diff;
        diff= this.getBeginColumn()-n.getBeginColumn();
        if (diff!=0) return diff;
        // A child node is considered to come after its parent.
        diff= n.getEndLine()-this.getEndLine();
        if (diff!=0) return diff;
        return n.getEndColumn()-this.getEndColumn();
    }

    void clearChildren();
    int getChildCount();
    /**
      * Most implementations of this should return a copy or
      * an immutable wrapper around the list.
      */
    default List<Node> children() {
        List<Node> result= new ArrayList<> ();
        for (int i= 0; i<getChildCount(); i++) {
            result.add(getChild(i));
        }
        return result;
    }

    // The following 3 methods will typically delegate
    // straightforwardly to a Map<String, Object> object-s get/set/containsKey/keySet methods.
    Object getAttribute(String name);
    void setAttribute(String name, Object value);
    boolean hasAttribute(String name);
    java.util.Set<String> getAttributeNames();
    FileLineMap getFileLineMap();
    default String getInputSource() {
        FileLineMap fileLineMap= getFileLineMap();
        return fileLineMap== null?"input":
        fileLineMap.getInputSource();
    }

    void setInputSource(FileLineMap fileLineMap);
    default String getSource() {
        return getFileLineMap().getText(getBeginLine(), getBeginColumn(), getEndLine(), getEndColumn());
    }

    int getBeginLine();
    int getEndLine();
    int getBeginColumn();
    int getEndColumn();
    void setBeginLine(int beginLine);
    void setEndLine(int endLine);
    void setBeginColumn(int beginColumn);
    void setEndColumn(int endColumn);
    default String getLocation() {
        return"line "+getBeginLine()+", column "+getBeginColumn()+" of "+getInputSource();
    }

    /**
      *  A regular node was created by the regular operations of the parsing machinery
      * applying the rules, consuming tokens and building up the tree.
      * An unparsed node is typically created as part of error recovery or possibly
      * some post-parsing tree-walking adjustments maybe.
      */
    default boolean isUnparsed() {
        return false;
    }

    void setUnparsed(boolean b);
    default<T extends Node> T firstChildOfType(Class<T> clazz) {
        for (Node child : children()) {
            if (clazz.isInstance(child)) {
                return clazz.cast(child);
            }
        }
        return null;
    }

    default<T extends Node> List<T> childrenOfType(Class<T> clazz) {
        List<T> result= new java.util.ArrayList<> ();
        for (Node child : children()) {
            if (clazz.isInstance(child)) {
                result.add(clazz.cast(child));
            }
        }
        return result;
    }

    default<T extends Node> List<T> descendantsOfType(Class<T> clazz) {
        List<T> result= new ArrayList<T> ();
        for (Node child : children()) {
            if (clazz.isInstance(child)) {
                result.add(clazz.cast(child));
            }
            result.addAll(child.descendantsOfType(clazz));
        }
        return result;
    }

    default<T extends Node> T firstAncestorOfType(Class<T> clazz) {
        Node parent= this;
        while (parent!=null) {
            parent= parent.getParent();
            if (clazz.isInstance(parent)) {
                return clazz.cast(parent);
            }
        }
        return null;
    }

    default Node findNodeAt(int line, int column) {
        if (!isIncluded(line, column)) {
            return null;
        }
        for (Node child : children()) {
            Node match= child.findNodeAt(line, column);
            if (match!=null) {
                return match;
            }
        }
        return this;
    }

    /**
     * Returns true if the given position (line,column) is included in the given
     * node and false otherwise.
     * 
     * @param line   the line position
     * @param column the column position
     * @return true if the given position (line,column) is included in the given
     *         node and false otherwise.
     */
    default boolean isIncluded(int line, int column) {
        return isIncluded(getBeginLine(), getBeginColumn(), getEndLine(), getEndColumn(), line, column);
    }

    default boolean isIncluded(int beginLine, int beginColumn, int endLine, int endColumn, int line, int column) {
        if (beginLine== line&&beginColumn== column) {
            return true;
        }
        if (endLine== line&&endColumn== column) {
            return true;
        }
        return!isAfter(beginLine, beginColumn, line, column)&&isAfter(endLine, endColumn, line, column);
    }

    /**
     * Returns the first child of this node. If there is no such node, this returns
     * <code>null</code>.
     * 
     * @return the first child of this node. If there is no such node, this returns
     *         <code>null</code>.
     */
    default Node getFirstChild() {
        return getChildCount()> 0?getChild(0):
        null;
    }

    /**
     * Returns the last child of the given node. If there is no such node, this
     * returns <code>null</code>.
     * 
     * @return the last child of the given node. If there is no such node, this
     *         returns <code>null</code>.
     */
    default Node getLastChild() {
        int count= getChildCount();
        return count> 0?getChild(count-1):
        null;
    }

    static boolean isAfter(int line1, int column1, int line2, int column2) {
        if (line1> line2) {
            return true;
        }
        if (line1== line2) {
            return column1>=column2;
        }
        return false;
    }

    default Node getRoot() {
        Node parent= this;
        while (parent.getParent()!=null) {
            parent= parent.getParent();
        }
        return parent;
    }

    static public List<Token> getTokens(Node node) {
        List<Token> result= new ArrayList<Token> ();
        for (Node child : node.children()) {
            if (child instanceof Token) {
                result.add((Token) child);
            }
            else {
                result.addAll(getTokens(child));
            }
        }
        return result;
    }

    static public List<Token> getRealTokens(Node n) {
        List<Token> result= new ArrayList<Token> ();
        for (Token token : getTokens(n)) {
            if (!token.isUnparsed()) {
                result.add(token);
            }
        }
        return result;
    }

    default List<Node> descendants(Filter filter) {
        List<Node> result= new ArrayList<> ();
        for (Node child : children()) {
            if (filter.accept(child)) {
                result.add(child);
            }
            result.addAll(child.descendants(filter));
        }
        return result;
    }

    public interface Filter {
        boolean accept(Node node);
    }
    static abstract public class Visitor {
        static private java.lang.reflect.Method baseVisitMethod;
        private HashMap<Class<? extends Node>, Method> methodCache= new HashMap<Class<? extends Node>, java.lang.reflect.Method>();
        static private java.lang.reflect.Method getBaseVisitMethod() throws NoSuchMethodException {
            if (baseVisitMethod== null) {
                baseVisitMethod= Node.Visitor.class.getMethod("visit", new Class[]{Node.class});
            }
            return baseVisitMethod;
        }

        private java.lang.reflect.Method getVisitMethod(Node node) {
            Class<?extends Node> nodeClass= node.getClass();
            if (!methodCache.containsKey(nodeClass)) {
                try {
                    Method method= this.getClass().getMethod("visit", new Class[]{nodeClass});
                    if (method.equals(getBaseVisitMethod())) {
                        method= null;
                        // Have to avoid infinite recursion, no?
                    }
                    methodCache.put(nodeClass, method);
                }
                catch(NoSuchMethodException nsme) {
                    methodCache.put(nodeClass, null);
                }
            }
            return methodCache.get(nodeClass);
        }

        /**
		 * Tries to invoke (via reflection) the appropriate visit(...) method
		 * defined in a subclass. If there is none, it just calls the fallback() routine. 
		 */
        public final void visit(Node node) {
            java.lang.reflect.Method visitMethod= getVisitMethod(node);
            if (visitMethod== null) {
                fallback(node);
            }
            else try {
                visitMethod.invoke(this, new Object[]{node});
            }
            catch(InvocationTargetException ite) {
                Throwable cause= ite.getCause();
                if (cause instanceof RuntimeException) {
                    throw(RuntimeException) cause;
                }
                throw new RuntimeException(ite);
            }
            catch(IllegalAccessException iae) {
                throw new RuntimeException(iae);
            }
        }

        public final void recurse(Node node) {
            for (Node child : node.children()) {
                visit(child);
            }
        }

        /**
		 * If there is no specific method to visit this node type,
		 * it just uses this method. The default base implementation
		 * is just to recurse over the nodes.
		 */
        public void fallback(Node node) {
            recurse(node);
        }

    }
}
