options {
   BASE_SRC_DIR = "../../../";
   PARSER_PACKAGE = "de.compilerbau.NewAwkCompiler.javacc21";
   //DEBUG_PARSER = true;
   //DEBUG_TOKEN_MANAGER = true;
   VISITOR = true;
}

PARSER_BEGIN(NewAwkParser)

import de.compilerbau.NewAwkCompiler.Visitors.*;
import de.compilerbau.NewAwkCompiler.javacc21.*;
import java.io.*;
import java.util.*;

public class NewAwkParser {
    private static String testToken;
    static public ArrayList<Node> roots= new ArrayList<>();

    public static void main(String[] args) throws ParseException, FileNotFoundException {
     System.err.println("Arguments: " + args.length);
     for (String s: args
          ) {
         System.err.println("Arg: " + s);
     }
     List<File> failures = new ArrayList<File>();
     List<File> successes = new ArrayList<File>();
     boolean failureOccurred = false;
     NewAwkParser parser;
     if (args.length == 0) {
         usage();
     }
     List<File> files = new ArrayList<File>();
     for (String arg : args) {
         File file = new File(arg);
         if (!file.exists()) {
             System.err.println("File " + file + " does not exist.");
             continue;
         }
         addFilesRecursively(files, file);
     }
     long startTime = System.currentTimeMillis();
     for (File file : files) {
         try {
             // A bit screwball, we'll dump the tree if there is only one arg. :-)
             parseFile(file, files.size() >= 1);
         }
         catch (Exception e) {
             System.err.println("Error processing file: " + file);
             e.printStackTrace();
             failures.add(file);
             continue;
         }
         System.out.println(file.getName()  + " parsed successfully.");
         successes.add(file);
     }
     for (File file : failures) {
         System.out.println("Parse failed on: " + file);
     }
     System.out.println("\nParsed " + successes.size() + " files successfully");
     System.out.println("Failed on " + failures.size() + " files.");
     System.out.println("\nDuration: " + (System.currentTimeMillis() - startTime) + " milliseconds");
 }

         static public void parseFile(File file, boolean dumpTree) throws IOException, ParseException {
             FileReader fr = new FileReader(file);
             NewAwkParser parser = new NewAwkParser(fr);
             parser.setInputSource(file.toString());
             Node root=parser.CompilationUnit();
     // Uncomment the following code if you want all the parsed trees
     //  to remain in memory. This is useful if you want to know how much
     //  memory it takes to parse all the source code in the JDK, for example.
     //  (About 8GB if we're talking about JDK 13)
     //       roots.add(root);
     //       if (roots.size() % 1000 == 0) {
     //            System.out.println("-----------------------------------------------");
     //            System.out.println("Parsed "  +  roots.size() + " files.");
     //            System.out.println("-----------------------------------------------");
     //       }

             if (dumpTree) {
                 Nodes.dump(root, ">");
                 DumpVisitor dumpVisitor = new DumpVisitor();
                 SymbolTableBuilderVisitor symbolTableBuilderVisitor = new SymbolTableBuilderVisitor();
                 if(root instanceof CompilationUnit) {
                     System.out.println("Entering Visitors...");
                     ((CompilationUnit) root).jjtAccept(dumpVisitor, null);
                     ((CompilationUnit) root).jjtAccept(symbolTableBuilderVisitor, null);
                 }
             }
        }

         static public void addFilesRecursively(List<File> files, File file) {
             if (file.isDirectory()) {
                 for (File f : file.listFiles()) {
                     addFilesRecursively(files, f);
                 }
             }
             else if (file.getName().endsWith("java") &&
                     !file.getName().endsWith("-info.java") ||
                     file.getName().endsWith("txt") &&
                     !file.getName().endsWith("-info.java")
             ) {
                 files.add(file);
             }
         }

         static public void usage() {
             System.out.println("Usage: java JParse <sourcefiles or directories>");
             System.out.println("If you just pass it one java source file, it dumps the AST");
             System.exit(-1);
         }
}
PARSER_END(NewAwkParser)
/*
    ==============================================================================================
    Lexer token deinifitions are defined in this section.
    ==============================================================================================
*/
SKIP :
{ <WHITESPACE: " ">
| <TAB: "\t">
| <NEW_LINE: "\n">
| <CARRIAGE_RETURN: "\r">
}
TOKEN : /* OPERATORS */
{ <PLUS: "+">
| <MINUS: "-">
| <MULTIPLICATION: "*">
| <DIVISION: "/">
| <MODULO: "%">
| <Zuweisung: "=">
| <EQUAL: "==">
| <NOT_EQUAL: "!=">
| <G_OR_EQUAL: ">=">
| <S_OR_EQUAL: "<=">
| <GREATER: ">">
| <SMALLER: "<">
| <Colon: ":">
| <ConditionalAnd: "&&">
| <ConditionalOr: "||">
| <ConditionalNot: "!">
| <Exponentiation: "^">
}
TOKEN : /* KEYWORDS */
{ <RETURN : "return">
| <VOID: "void">
| <NullLiteral: "null">
| <IF: "if">
| <ELSE: "else">
| <THIS: "this">
| <INTEGER_CLASS: "Integer">
| <DOUBLE_CLASS: "Double">
| <CHAR_CLASS: "Char">
| <BOOLEAN_CLASS: "Boolean">
}
TOKEN : /* SEPARATORS */
{ <KlammerAuf: "(">
| <KlammerZu: ")">
| <BlockAuf: "{">
| <BlockZu: "}">
| <ArrayAuf: "[">
| <ArrayZu: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
| <Apostrophe: "'">
| <AT: "@">
}
TOKEN : /* BASIC */
{ <TypeInt: "int">
| <TypeDouble: "double">
| <TypeChar: "char">
| <TypeBoolean: "boolean">
| <TypeString: "String">
| <#LETTER: ["_","a"-"z","A"-"Z"]>
| <#DIGIT: ["0"-"9"]>
| <#EXPO: ["e","E"]("+"|"-")?(<DIGIT>)+>
}
TOKEN : /* LITERALS */
{ <#TRUE: "true">
| <#FALSE: "false">
| <BooleanLiteral: (<TRUE>|<FALSE>)>
| <CharLiteral: <Apostrophe> (<LETTER> | <DIGIT>) <Apostrophe>>
| <IntegerLiteral: (<DIGIT>)+>
| <DoubleLiteral: ((<DIGIT>)+<DOT>(<DIGIT>)*(<EXPO>)?) | ((<DIGIT>)*<DOT> (<DIGIT>)+(<EXPO> )?)>
| <ID: <LETTER>(<DIGIT>|<LETTER>)*>
| <StringLiteral: "\"" <STRING_CONTENT> "\"">
| <#STRING_CONTENT: (<LETTER>|<DIGIT>|<DoubleLiteral>|(" ") )* >
| <PRINT_LINE: "System.out.println">
| <PRINT: "System.out.print">
| <LENGTH: "length()">
}
/*
    ==============================================================================================
    Parser Rules and AST generation are defined/handled in this section
    ==============================================================================================
*/
Node CompilationUnit() #CompilationUnit : {}
{
    (LOOKAHEAD(3) VariableDecl() |
     LOOKAHEAD(3) Assignement() |
     LOOKAHEAD(3) VariableDeclAndAssignement() |
     MethodDecl())+
    <EOF>
    {return jjtThis;}
}
void VariableDecl() #VariableDecl : {}
{
       Type() <ID> <SEMICOLON>
}
void Assignement() #Assignement: {}
{
    <ID> <Zuweisung> ExprStmnt()
}
void VariableDeclAndAssignement() #VariableDeclAndAssignement : {}
{
    Type() <ID> <Zuweisung> ExprStmnt()
}
void MethodDecl() #MethodDecl : { Token t;}
{
    (
        Type()
        |
        <VOID>  {jjtThis.isVoid = true;}
    )
    t=<ID> {jjtThis.id = (ID) t;}
    <KlammerAuf>
    ParameterList()
    <KlammerZu> Block()
}
void ParameterList() #ParameterList : {} {
    [Type() <ID>] (<COMMA> Type() <ID>)*
}
void Stmnt() #Stmnt : {}
{
     (
     //LOOKAHEAD(3) ExprStmnt() |
       Block()
     | IfStmnt()
     | ReturnStmnt()
     | LOOKAHEAD(3) VariableDecl()
     | LOOKAHEAD(3) Assignement()
     | LOOKAHEAD(3) VariableDeclAndAssignement()
     | PrintStmnt()
     | LOOKAHEAD(3) KlammerAffe()
      )
}
void Block() #Block : {}
{
    <BlockAuf> (Stmnt())+ <BlockZu>
}
void IfStmnt() #IfStmnt : {}
{
    <IF> <KlammerAuf> Expr() <KlammerZu> Stmnt() (<ELSE> Stmnt())* <SEMICOLON>
}
void ExprStmnt() #ExprStmnt : {}
{
    Expr() <SEMICOLON>
}
void Expr() #Expr : {}
{
    LogicalOrExpr() ( <Zuweisung> LogicalOrExpr())*
}
/**
* OPERATORs (Nodes not in AST becuase precedence comes from nesting order)
*/
void LogicalOrExpr() #LogicalOrExpr : {}
{
    LogicalAndExpr() (<ConditionalOr> LogicalAndExpr())*
}
void LogicalAndExpr() #LogicalAndExpr : {}
{
    LogicalNotExpr() (<ConditionalAnd> LogicalNotExpr())*
}
void LogicalNotExpr() #LogicalNotExpr : {}
{
    [<ConditionalNot>] CompExpr()
}
void CompExpr() #CompExpr : {}
{
    Sum() ((<GREATER> | <SMALLER>  | <S_OR_EQUAL> | <G_OR_EQUAL> | <NOT_EQUAL>) Sum())*
}
void Sum() #Sum : {}
{
    Product() ((<PLUS> | <MINUS> ) Product())*
}
void Product() #Product : {}
{
    Sign() ((<MULTIPLICATION> | <DIVISION> | <MODULO>) Sign() )*
}
void Sign() #Sign : {}
{
    Atom() | (<PLUS> | <MINUS> ) Atom()
}
/**
* OPERATORs end -------------
*/
void Atom() #Atom : {
    Token t;
}
{
    (
        (t=<ID>
            ([ArrayAccess()
                {jjtThis.isArrayAccess = true;}
            ]
            [".length()"
                {jjtThis.hasLength = true;
                //Length needs to be determined by id value
                //See Symboltable
                }
            ])
        )
        | <KlammerAuf> Expr() <KlammerZu>
            {jjtThis.isExpression = true;
            }
        | t=<BooleanLiteral>
            {jjtThis.type = new Type("boolean");
             jjtThis.value = t.getImage();
             }
        | t=<IntegerLiteral>
            {jjtThis.type = new Type("int");
             jjtThis.value = t.getImage();
             }
        | t=<DoubleLiteral>
            {jjtThis.type = new Type("double");
             jjtThis.value = t.getImage();
             }
        | t=<CharLiteral>
            {jjtThis.type = new Type("char");
             jjtThis.value = t.getImage();
             }
        | t=<NullLiteral>
        | LOOKAHEAD(3) t=<StringLiteral>
            [(".length()"
               {jjtThis.hasLength = true;
               jjtThis.atomLength = t.getImage().length();}

            |".isInt()"
                {jjtThis.isInt = true;}

            |".isDouble()"
                {jjtThis.isDouble = true;}

            |".toInt()"
                {jjtThis.toInt = true;}

            |".toDouble()"
                {jjtThis.toDouble = true;}
            )]
    )
}
void MethodCall() #MethodCall : {}
{
    <ID> <KlammerAuf>
    [Expr() {/*Add Arg*/}
    (<COMMA> Expr(){/*Add more args*/})*]
    <KlammerZu>
}
void ArrayAccess() #ArrayAccess : {}
{
    <ArrayAuf> Expr() <ArrayZu>
}
void Type() #Type : {
    Token t;
}
{
  (t=<TypeInt> | t=<TypeDouble> | t=<TypeChar> | t=<TypeBoolean> | t=<TypeString>)
  {
       jjtThis.type = t.getImage(); //assign String-Value to Type
  }
  (
  <ArrayAuf> <ArrayZu>
      {
          jjtThis.isArray = true;
          jjtThis.dimension++;
      }
  )*
}
void ReturnStmnt() #ReturnStatement : {}
{
    <RETURN> Expr() <SEMICOLON>
}
void KlammerAffe() #KlammerAffe : {}
{
    <StringLiteral> <AT> <BlockAuf>
    KlammerAffeRegex() KlammerAffeAusdruck()
    (KlammerAffeRegex() KlammerAffeAusdruck())*
    <BlockZu>
}
void KlammerAffeRegex() #KlammerAffeRegex : {}
{
    [<ConditionalNot>] <Colon> (<INTEGER_CLASS> | <DOUBLE_CLASS> | <CHAR_CLASS> | <BOOLEAN_CLASS> | <TypeString> ) <Colon>
}
void KlammerAffeAusdruck() #KlammerAffeAusdruck : {}
{
    <BlockAuf>
    <RETURN> [(<THIS> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanLiteral>)] <SEMICOLON>
    <BlockZu>
}
void PrintStmnt() #PrintStmnt :
{}
{
  (<PRINT_LINE> | <PRINT> ) <KlammerAuf> Expr() <KlammerZu> <SEMICOLON>
}
