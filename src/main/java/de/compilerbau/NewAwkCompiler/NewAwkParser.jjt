options {
   BASE_SRC_DIR = "../../../";
   PARSER_PACKAGE = "de.compilerbau.NewAwkCompiler.javacc21";
   DEBUG_PARSER = true;
   DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(NewAwkParser)

import java.util.*;
import java.io.*;

public class NewAwkParser {
 private static String testToken;

 public static void main(String[] args) throws ParseException, FileNotFoundException {
     File file = new File(".\\src\\main\\java\\de\\compilerbau\\NewAwkCompiler\\NewAwkTest.txt");
     FileInputStream is = new FileInputStream(file);
     NewAwkParser parser = new NewAwkParser(new BufferedInputStream(is));
     parser.program();

     parser.printTokens(testToken);

     }
     private void printTokens(String testToken) {
        System.out.println("Test: " + testToken);
     }
}
PARSER_END(NewAwkParser)
/*
    ==============================================================================================
    Lexer token deinifitions are defined in this section.
    ==============================================================================================
*/
SKIP :
{ <WHITESPACE: " ">
| <TAB: "\t">
| <NEW_LINE: "\n">
| <CARRIAGE_RETURN: "\r">
}
TOKEN #Operator : /* OPERATORS */
 <PLUS: "+">
| <MINUS: "-">
| <MULTIPLICATION: "*">
| <DIVISION: "/">
| <MODULO: "%">
| <Zuweisung: "=">
| <EQUAL: "==">
| <NOT_EQUAL: "!=">
| <G_OR_EQUAL: ">=">
| <S_OR_EQUAL: "<=">
| <GREATER: ">">
| <SMALLER: "<">
| <Colon: ":">
| <ConditionalAnd: "&&">
| <ConditionalOr: "||">
| <ConditionalNot: "!">
| <Exponentiation: "^">
;
TOKEN : /* KEYWORDS */
{ <RETURN : "return">
}
TOKEN : /* SEPARATORS */
{ <KlammerAuf: "(">
| <KlammerZu: ")">
| <BlockAuf: "{">
| <BlockZu: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
}
TOKEN : /* BASIC */
{ <#LETTER: ["_","a"-"z","A"-"Z"]>
| <#DIGIT: ["0"-"9"]>
| <#EXPO: ["e","E"]("+"|"-")?(<DIGIT>)+>
| <DataType: ("int"|"double"|"char"|"boolean"|"String")>
| <ArrayType: <DataType> <LBRACKET> <RBRACKET>>
/*| <Type: <ArrayType> | <DataType> >*/
| <Apostrophe: "'">
| <BooleanConditionalAnd: <BooleanValue><ConditionalAnd><BooleanValue>
                          (<ConditionalAnd><BooleanValue> )* >
| <BooleanConditionalOr: <BooleanValue><ConditionalOr><BooleanValue>
                          (<ConditionalOr><BooleanValue> )* >
| <BooleanConditionalNot: (<ConditionalNot><BooleanValue>)>

}
TOKEN : /* LITERALS */
{ <CharLiteral: <Apostrophe> (<LETTER> | <DIGIT>) <Apostrophe>>
| <VOID: "void">
| <NullLiteral: "null">
| <BooleanValue: (<TRUE>|<FALSE>)>
| <#TRUE: "true">
| <#FALSE: "false">
| <IntegerLiteral: (<DIGIT>)+>
| <DoubleLiteral: ((<DIGIT>)+<DOT>(<DIGIT>)*(<EXPO>)?) | ((<DIGIT>)*<DOT> (<DIGIT>)+(<EXPO> )?)>
| <Bezeichner: <LETTER>(<DIGIT>|<LETTER>)*>
| <StringLiteral: "\"" <STRING_CONTENT> "\"">
| <#STRING_CONTENT: (<LETTER>|<DIGIT>)* >
}
/*
    ==============================================================================================
    Parser Rules and AST generation are defined/handled in this section
    ==============================================================================================
*/
Node program() #Program : {}
{
    fieldOrMethods()
    <EOF>
    {return jjtThis;}
}
fieldOrMethods() #FieldOrMethods : {}
{
     (SCAN fieldDeclarationAndAssignment() | methodDeclaration())+
}
fieldDeclarationAndAssignment() #FieldDeclarationAndAssignment: {}
{
    <DataType> assignment()
}
assignment() #Assignment: {}
{
    <Bezeichner> <Zuweisung>
    (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanValue> | <StringLiteral> | <NullLiteral> )
    <SEMICOLON>
}
arrayAssignment() #ArrayAssignment: {}
{
    <ArrayType> assignment()
}
methodDeclaration() #Method : {}
{
    methodSignature()
    methodBody()
}
methodSignature() #MethodSignature : {}
{
    (<DataType> | <ArrayType> | <VOID>) <Bezeichner> <KlammerAuf> parameterList() <KlammerZu>
}
parameterList() #ParameterList : {}
{
    (<DataType> | <ArrayType>) <Bezeichner> [<COMMA> (<DataType> | <ArrayType>) <Bezeichner>]
}
methodBody() #MethodBody : {}
{
    <BlockAuf> (assignment() | fieldDeclarationAndAssignment() | returnStatement())+ <BlockZu>
}
returnStatement() #ReturnStatement : {}
{
    <RETURN>
    (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral>
    | <BooleanValue> | <StringLiteral> | <NullLiteral> )
    <SEMICOLON>
}
comparision() #Comparision:
{}
{
    (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanValue> | <StringLiteral> | <NullLiteral> )
    (<EQUAL> | <NOT_EQUAL> | <SMALLER> | <S_OR_EQUAL> | <GREATER> | <G_OR_EQUAL>)
    (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanValue> | <StringLiteral> | <NullLiteral> )
}