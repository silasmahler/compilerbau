options {
   DEBUG_PARSER = true;
   DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(NewAwkParser)

package de.compilerbau.NewAwkCompiler.generated;

import java.util.*;
import java.io.*;
import de.compilerbau.NewAwkCompiler.generated.Token;


public class NewAwkParser {
 public static void main(String[] args) throws ParseException, FileNotFoundException, TokenMgrError {
     /*File file = new File(".\\src\\main\\java\\de\\compilerbau\\NewAwkCompiler\\NewAwkTestAddNumbers.txt");
     FileInputStream is = new FileInputStream(file);
     NewAwkParser parser = new NewAwkParser(new BufferedInputStream(is));
     parser.Start();*/

     File file2 = new File(".\\src\\main\\java\\de\\compilerbau\\NewAwkCompiler\\NewAwkTest.txt");
     FileInputStream is2 = new FileInputStream(file2);
     NewAwkParser parser2 = new NewAwkParser(new BufferedInputStream(is2));
     parser2.program();

     }
}
PARSER_END(NewAwkParser)
SKIP : {
<Whitespace: " ">
| <Tab: "\t">
| <Newline: "\n">
| <CarriageReturn: "\r">
}
TOKEN : {
<#Alphabet: ["a"-"z","A"-"Z"]>
| <#Digit: ["0"-"9"]>
| <#Expo: ["e","E"]("+"|"-")?(<Digit>)+>
| <Datentyp: ("int"|"double"|"char"|"boolean"|"String")>
| <CharLiteral: <Apostrophe> (<Alphabet> | <Digit>) <Apostrophe>>
| <ArrayType: <Datentyp>"[]">
| <Type: <Datentyp> | <ArrayType>>
| <Schluesselwort: ("if"|"else"|"while"|"do"|"return"|"break"|"switch"|"case"|"for")>
| <Void: "void">
| <Bezeichner: <Alphabet>(<Digit>|<Alphabet>)*>
| <ConditionalAndExpression: "&&">
| <ConditionalOrExpression: "||">
| <ConditionalNotExpression: "!">
| <KlammerAuf: "(">
| <KlammerZu: ")">
| <BlockAuf: "{">
| <BlockZu: "}">
| <IntegerLiteral: (<Digit>)+>
| <DoubleLiteral: ((<Digit>)+"."(<Digit>)*(<Expo>)?)
| ((<Digit>)*"."(<Digit>)+(<Expo>)?)>

| <PlusSymbol: "+">
| <MinusSymbol: "-">
| <Multiplikation: "*">
| <Division: "/">
| <ModuloOperator: "%">

| <Exponentiation: "^">
| <BooleanExpression: ("true"|"false")>

| <Equal: "==">
| <NotEqual: "!=">
| <GreaterOrEqual: ">=">
| <SmallerOrEqual: "<=">
| <Greater: ">">
| <Smaller: "<">
| <Semicolon: ";">
| <Zuweisung: "=">

| <NullLiteral: "null">
| <Commata: ",">
| <Apostrophe: "'">

}

void program() : {}
{
    (method() | fieldDeclaration())*
}
void method() : {}
{
    methodSignature()
    methodBody()
}
void methodCall() : {}
{
    <Bezeichner>"()"
}
void fieldDeclaration() : {}
{
    <Type> <Bezeichner> <Zuweisung>
    (<IntegerLiteral> | <DoubleLiteral> )
}
void methodBody() : {}
{
    <BlockAuf> (fieldDeclaration() | methodCall())+ <BlockZu>
}
void methodSignature() : {}
{
    (<Type> | <Void> ) <Bezeichner> <KlammerAuf> parameterListe() <KlammerZu>
}
void parameterListe() :
{}
{
    <Type> <Bezeichner> (<Commata> <Type> <Bezeichner>)*
}
void intDoubleCharOperation() :
{}
{
    (<IntegerLiteral> | <DoubleLiteral> | <CharLiteral>)
    (<PlusSymbol> | <MinusSymbol> | <Multiplikation> | <Division> | <ModuloOperator> )
    (<IntegerLiteral> | <DoubleLiteral> | <CharLiteral>)
}


void test() :
{}
{
    <BlockAuf>
}

void adderSubstracter() :
{}
{
    <IntegerLiteral> (<PlusSymbol> <IntegerLiteral>)* (<MinusSymbol> <IntegerLiteral>)* <EOF>
}
