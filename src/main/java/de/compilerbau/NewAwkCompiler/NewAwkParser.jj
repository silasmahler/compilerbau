options {
   DEBUG_PARSER = true;
   DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(NewAwkParser)

package de.compilerbau.NewAwkCompiler.generated;

import java.util.*;
import java.io.*;
import de.compilerbau.NewAwkCompiler.generated.Token;


public class NewAwkParser {
 public static void main(String[] args) throws ParseException, FileNotFoundException, TokenMgrError {
     /*File file = new File(".\\src\\main\\java\\de\\compilerbau\\NewAwkCompiler\\NewAwkTestAddNumbers.txt");
     FileInputStream is = new FileInputStream(file);
     NewAwkParser parser = new NewAwkParser(new BufferedInputStream(is));
     parser.Start();*/

     File file2 = new File(".\\src\\main\\java\\de\\compilerbau\\NewAwkCompiler\\NewAwkTest.txt");
     FileInputStream is2 = new FileInputStream(file2);
     NewAwkParser parser2 = new NewAwkParser(new BufferedInputStream(is2));
     parser2.program();

     }
}
PARSER_END(NewAwkParser)
SKIP :
{ <WHITESPACE: " ">
| <TAB: "\t">
| <NEW_LINE: "\n">
| <CARRIAGE_RETURN: "\r">
}
TOKEN : /* OPERATORS and CONDITONAL OPERATORS */
{ <PLUS: "+">
| <MINUS: "-">
| <MULTIPLICATION: "*">
| <DIVISION: "/">
| <MODULO: "%">
| <Zuweisung: "=">
| <EQUAL: "==">
| <NOT_EQUAL: "!=">
| <G_OR_EQUAL: ">=">
| <S_OR_EQUAL: "<=">
| <GREATER: ">">
| <SMALLER: "<">
}
TOKEN : /* KEYWORDS */
{ <IF : "if">
| <ELSE : "else">
| <WHILE: "while">
| <DO : "do">
| <FOR : "for">
| <SWITCH : "switch">
| <CASE : "case">
| <RETURN : "return">
| <BREAK : "break">
}
TOKEN : /* BASIC */
{ <#LETTER: ["_","a"-"z","A"-"Z"]>
| <#DIGIT: ["0"-"9"]>
| <#EXPO: ["e","E"]("+"|"-")?(<DIGIT>)+>
| <Type: <Datentyp> | <ArrayType>>
| <ArrayType: <Datentyp><BracketOpen><BracketClose>>
| <Datentyp: ("int"|"double"|"char"|"boolean"|"String")>
| <Exponentiation: "^">
| <Commata: ",">
| <Apostrophe: "'">
| <Colon: ":">
| <SEMICOLON : ";">
}
TOKEN : /* LITERALS */
{ <CharLiteral: <Apostrophe> (<LETTER> | <DIGIT>) <Apostrophe>>
| <IntegerLiteral: (<DIGIT>)+>
| <DoubleLiteral: ((<DIGIT>)+"."(<DIGIT>)*(<EXPO>)?) | ((<DIGIT>)*"."(<DIGIT>)+(<EXPO> )?)>
| <VOID: "void">
| <NullLiteral: "null">
| <Bezeichner: <LETTER>(<DIGIT>|<LETTER>)*>
| <VALUE: (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanExpression> | <StringLiteral> | <NullLiteral> )>
| <StringLiteral: "\"" <STRING_CONTENT> "\"">
| <#STRING_CONTENT: (<LETTER>|<DIGIT>)* >
| <BooleanExpression: (<TRUE>|<FALSE>)>
| <#TRUE: "true">
| <#FALSE: "false">
}
TOKEN : /* CONDITIONALS and BRACKETS*/
{ <ConditionalAndExpression: "&&">
| <ConditionalOrExpression: "||">
| <ConditionalNotExpression: "!">
| <KlammerAuf: "(">
| <KlammerZu: ")">
| <BlockAuf: "{">
| <BlockZu: "}">
| <BracketOpen: "[">
| <BracketClose: "]">
}

void program() : {}
{
    { System.out.println("ENTER: program()"); }
    (method() | fieldDeclaration())*
}
void returnStatement(): {}
{
    { System.out.println("ENTER: returnStatement()"); }
    <RETURN> <VALUE> <SEMICOLON>
}
Token operator():
{
  Token tok;
}
{
  tok=<PLUS>
  {
    System.out.println(tok.image);
    return tok;
  }
  |tok=<MINUS>
  {
    System.out.println(tok.image);
    return tok;
  }
  |tok=<MULTIPLICATION>
  {
    System.out.println(tok.image);
    return tok;
  }
  |tok=<DIVISION>
  {
    System.out.println(tok.image);
    return tok;
  }
  |tok=<MODULO>
  {
    System.out.println(tok.image);
    return tok;
  }
}
void expression(Token writeTo):
{
  Token t1, t2, t3;
}
{
  t1 = <VALUE>
  t2 = operator()
  t3 = <VALUE>
  <SEMICOLON>
{
  if(t2.image.equals("+"))
  {
      System.out.println("ADD "+t1.image+" "+t2.image);
  }
}
}
void condition():
{}
{
    <VALUE> condOperator() <VALUE>
}
void condOperator():
{}
{
  (<EQUAL> | <NOT_EQUAL> | <SMALLER> | <S_OR_EQUAL> | <GREATER> | <G_OR_EQUAL>)
}
void method() : {}
{
    { System.out.println("ENTER: method()"); }
    methodSignature()
    methodBody()
}
void methodCall() : {}
{
    <Bezeichner>"()"
}
void fieldDeclaration() : {}
{
    <Type> <Bezeichner> <Zuweisung> <VALUE>
}
void methodBody() : {}
{
    <BlockAuf> (fieldDeclaration() | methodCall() | returnStatement())+ <BlockZu>
}
void methodSignature() : {}
{
    (<Type> | <VOID> ) <Bezeichner> <KlammerAuf> parameterListe() <KlammerZu>
}
void parameterListe() :
{}
{
    <Type> <Bezeichner> (<Commata> <Type> <Bezeichner>)*
}
void booleanValue(): {}
{
(<BooleanExpression>)
}


void intDoubleCharOperation() :
{}
{
    (<IntegerLiteral> | <DoubleLiteral> | <CharLiteral>)
    (<PLUS> | <MINUS> | <MULTIPLICATION> | <DIVISION> | <MODULO> )
    (<IntegerLiteral> | <DoubleLiteral> | <CharLiteral>)
}


void test() :
{}
{
    <BlockAuf>
}

void adderSubstracter() :
{}
{
    <IntegerLiteral> (<PLUS> <IntegerLiteral>)* (<MINUS> <IntegerLiteral>)* <EOF>
}
