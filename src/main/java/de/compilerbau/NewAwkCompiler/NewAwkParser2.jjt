options {
   BASE_SRC_DIR = "../../../";
   PARSER_PACKAGE = "de.compilerbau.NewAwkCompiler.javacc21";
   DEBUG_PARSER = true;
   DEBUG_TOKEN_MANAGER = true;
   VISITOR = true;
}

PARSER_BEGIN(NewAwkParser)

import de.compilerbau.NewAwkCompiler.javacc21.*;import de.compilerbau.NewAwkCompiler.javacc21.NewAwkParser;
import java.io.*;
import java.util.*;

public class NewAwkParser {
    private static String testToken;
    static public ArrayList<Node> roots= new ArrayList<>();

    public static void main(String[] args) throws ParseException, FileNotFoundException {
     /*File file = new File(".\\src\\main\\java\\de\\compilerbau\\NewAwkCompiler\\NewAwkTest.txt");
     FileInputStream is = new FileInputStream(file);
     NewAwkParser parser = new NewAwkParser(new BufferedInputStream(is));
     parser.program();

     parser.printTokens(testToken);

     }
     private void printTokens(String testToken) {
        System.out.println("Test: " + testToken);
     }*/

     System.err.println("Arguments: " + args.length);
     for (String s: args
          ) {
         System.err.println("Arg: " + s);
     }
     List<File> failures = new ArrayList<File>();
     List<File> successes = new ArrayList<File>();
     boolean failureOccurred = false;
     NewAwkParser parser;
     if (args.length == 0) {
         usage();
     }
     List<File> files = new ArrayList<File>();
     for (String arg : args) {
         File file = new File(arg);
         if (!file.exists()) {
             System.err.println("File " + file + " does not exist.");
             continue;
         }
         addFilesRecursively(files, file);
     }
     long startTime = System.currentTimeMillis();
     for (File file : files) {
         try {
             // A bit screwball, we'll dump the tree if there is only one arg. :-)
             parseFile(file, files.size() >= 1);
         }
         catch (Exception e) {
             System.err.println("Error processing file: " + file);
             e.printStackTrace();
             failures.add(file);
             continue;
         }
         System.out.println(file.getName()  + " parsed successfully.");
         successes.add(file);
     }
     for (File file : failures) {
         System.out.println("Parse failed on: " + file);
     }
     System.out.println("\nParsed " + successes.size() + " files successfully");
     System.out.println("Failed on " + failures.size() + " files.");
     System.out.println("\nDuration: " + (System.currentTimeMillis() - startTime) + " milliseconds");
 }

         static public void parseFile(File file, boolean dumpTree) throws IOException, ParseException {
             FileReader fr = new FileReader(file);
             NewAwkParser parser = new NewAwkParser(fr);
             parser.setInputSource(file.toString());
             Node root=parser.program();
     // Uncomment the following code if you want all the parsed trees
     //  to remain in memory. This is useful if you want to know how much
     //  memory it takes to parse all the source code in the JDK, for example.
     //  (About 8GB if we're talking about JDK 13)
     //       roots.add(root);
     //       if (roots.size() % 1000 == 0) {
     //            System.out.println("-----------------------------------------------");
     //            System.out.println("Parsed "  +  roots.size() + " files.");
     //            System.out.println("-----------------------------------------------");
     //       }

             if (dumpTree) {
                 Nodes.dump(root, "");
             }
         }

         static public void addFilesRecursively(List<File> files, File file) {
             if (file.isDirectory()) {
                 for (File f : file.listFiles()) {
                     addFilesRecursively(files, f);
                 }
             }
             else if (file.getName().endsWith("java") &&
                     !file.getName().endsWith("-info.java") ||
                     file.getName().endsWith("txt") &&
                     !file.getName().endsWith("-info.java")
             ) {
                 files.add(file);
             }
         }

         static public void usage() {
             System.out.println("Usage: java JParse <sourcefiles or directories>");
             System.out.println("If you just pass it one java source file, it dumps the AST");
             System.exit(-1);
         }
}}
}
PARSER_END(NewAwkParser)
/*
    ==============================================================================================
    Lexer token deinifitions are defined in this section.
    ==============================================================================================
*/
SKIP :
{ <WHITESPACE: " ">
| <TAB: "\t">
| <NEW_LINE: "\n">
| <CARRIAGE_RETURN: "\r">
}
TOKEN : /* OPERATORS */
{ <PLUS: "+">
| <MINUS: "-">
| <MULTIPLICATION: "*">
| <DIVISION: "/">
| <MODULO: "%">
| <Zuweisung: "=">
| <EQUAL: "==">
| <NOT_EQUAL: "!=">
| <G_OR_EQUAL: ">=">
| <S_OR_EQUAL: "<=">
| <GREATER: ">">
| <SMALLER: "<">
| <Colon: ":">
| <ConditionalAnd: "&&">
| <ConditionalOr: "||">
| <ConditionalNot: "!">
| <Exponentiation: "^">
}
TOKEN : /* KEYWORDS */
{ <RETURN : "return">
| <VOID: "void">
| <NullLiteral: "null">
| <IF: "if">
| <ELSE: "else">
}
TOKEN : /* SEPARATORS */
{ <KlammerAuf: "(">
| <KlammerZu: ")">
| <BlockAuf: "{">
| <BlockZu: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
}
TOKEN : /* BASIC */
{ <#LETTER: ["_","a"-"z","A"-"Z"]>
| <#DIGIT: ["0"-"9"]>
| <#EXPO: ["e","E"]("+"|"-")?(<DIGIT>)+>
| <DataType: ("int"|"double"|"char"|"boolean"|"String")>
| <ArrayType: <DataType> <LBRACKET> <RBRACKET>>
/*| <Type: <ArrayType> | <DataType> >*/
| <Apostrophe: "'">
}
TOKEN : /* LITERALS */
{ <CharLiteral: <Apostrophe> (<LETTER> | <DIGIT>) <Apostrophe>>
| <BooleanValue: (<TRUE>|<FALSE>)>
| <#TRUE: "true">
| <#FALSE: "false">
| <IntegerLiteral: (<DIGIT>)+>
| <DoubleLiteral: ((<DIGIT>)+<DOT>(<DIGIT>)*(<EXPO>)?) | ((<DIGIT>)*<DOT> (<DIGIT>)+(<EXPO> )?)>
| <Bezeichner: <LETTER>(<DIGIT>|<LETTER>)*>
| <StringLiteral: "\"" <STRING_CONTENT> "\"">
| <#STRING_CONTENT: (<LETTER>|<DIGIT>)* >
}
/*
    ==============================================================================================
    Parser Rules and AST generation are defined/handled in this section
    ==============================================================================================
*/

void Stmnt() #Stmnt : {}
{
    (ExprStmnt() | Block() | IfStmnt() | ReturnStmnt())
}

void ExprStmnt() #ExprStmnt : {}
{
    Expr() <SEMICOLON>
}
void IfStmnt() #IfStmnt : {}
{
    <IF> <KlammerAuf> Expr() <KlammerZu> Stmnt() (<ELSE> Stmnt())* <SEMICOLON>
}
void Expr() #Expr : {}
{
    LogicalOrExpr() ( <Zuweisung> LogicalOrExpr())*
}
void LogicalOrExpr() #LogicalOrExpr : {}
{
    LogicalAndExpr() (<ConditionalOr> LogicalAndExpr())*
}
void LogicalAndExpr() #LogicalAndExpr : {}
{
    LogicalNotExpr() (<ConditionalAnd> LogicalNotExpr())*
}
void LogicalNotExpr() #LogicalNotExpr : {}
{
    [<ConditionalNot>] CompExpr()
}
void CompExpr() #CompExpr : {}
{
    Sum() ((<GREATER> | <SMALLER>  | <S_OR_EQUAL> | <G_OR_EQUAL> | <NOT_EQUAL>) Sum())*
}
void Sum() #Sum : {}
{
    Product() ((<PLUS> | <MINUS> ) Product())*
}
void Product() #Product : {}
{
    Sign() ((<MULTIPLICATION> | <DIVISION> | <MODULO> | "") Sign() )*
}
void Sign() #Sign : {}
{
    Atom() [(<PLUS> | <MINUS> ) Atom() ]
}
void Atom() #Atom : {}
{
    [<KlammerAuf> Type() <KlammerZu>] ((MethodCall() | VariableUse() ) (ArrayAccess())*
    | <KlammerAuf> Expr() <KlammerZu> | <BooleanValue> | <IntegerLiteral> | <DoubleLiteral>
    | <StringLiteral> | <CharLiteral>)
}
void MethodCall() #MethodCall : {}
{
    <Bezeichner> <KlammerAuf> ArgumentList() <KlammerZu>
}
void VariableUse() #VariableUse : {}
{
    <Bezeichner>
}
void ArrayAccess() #ArrayAccess : {}
{
    [Expr()]
}
void ArgumentList() #ArgumentList : {}
{
    [Expr() (<COMMA> Expr())]
}
void Type() #IfStmnt : {}
{
    <DataType> (<KlammerAuf> <KlammerZu> )*
}
Node program() #Program : {
    Token t;
}
{
    fieldOrMethods()
    <EOF>
    {return jjtThis;}
}
void fieldOrMethods() #FieldOrMethods : {}
{
     (SCAN fieldDeclarationAndAssignment() | methodDeclaration())+
}
void fieldDeclarationAndAssignment() #FieldDeclarationAndAssignment : {}
{
    <DataType> assignment()
}
void assignment() #Assignment : {}
{
    <Bezeichner> <Zuweisung>
    (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanValue> | <StringLiteral> | <NullLiteral> )
    <SEMICOLON>
}
void arrayAssignment() #ArrayAssignment : {}
{
    <ArrayType> assignment()
}
void methodDeclaration() #Method : {}
{
    methodSignature()
    methodBody()
}
void methodSignature() #MethodSignature : {}
{
    (<DataType> | <ArrayType> | <VOID>) <Bezeichner> <KlammerAuf> parameterList() <KlammerZu>
}
void parameterList() #ParameterList : {}
{
    (<DataType> | <ArrayType>) <Bezeichner> [<COMMA> (<DataType> | <ArrayType>) <Bezeichner>]
}
void methodBody() #MethodBody : {}
{
    <BlockAuf> (assignment() | fieldDeclarationAndAssignment() | returnStmnt() )+ <BlockZu>
}
void returnStmnt() #ReturnStatement : {}
{
    <RETURN> Expr() <SEMICOLON>
}
void comparision() #Comparision:
{}
{
    (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanValue> | <StringLiteral> | <NullLiteral> )
    (<EQUAL> | <NOT_EQUAL> | <SMALLER> | <S_OR_EQUAL> | <GREATER> | <G_OR_EQUAL>)
    (<Bezeichner> | <IntegerLiteral> | <DoubleLiteral> | <CharLiteral> | <BooleanValue> | <StringLiteral> | <NullLiteral> )
}